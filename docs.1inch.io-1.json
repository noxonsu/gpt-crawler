[
  {
    "title": "RevertReasonParser | 1inch Network",
    "url": "https://docs.1inch.io/docs/limit-order-protocol/smart-contract/libraries/RevertReasonParser/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nIntroduction\nLimit vs. RFQ Orders\nOrder creation examples\nJS Utils\nBreaking changes in V3\nSmart contracts\nLimitOrderProtocol\nLimitOrderProtocolPro\nOrderLib\nOrderMixin\nOrderRFQMixin\nTable of contents\nhelpers\ninterfaces\nlibraries\nArgumentsDecoder\nPermitable\nRevertReasonParser\nLiquidity Source and API\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nLimit order protocolSmart contractslibrariesRevertReasonParser\nRevertReasonParser\n\nLibrary that allows to parse unsuccessful arbitrary calls revert reasons. See https://solidity.readthedocs.io/en/latest/control-structures.html#revert for details. Note that we assume revert reason being abi-encoded as Error(string) so it may fail to parse reason if structured reverts appear in the future.\n\nAll unsuccessful parsings get encoded as Unknown(data) string\n\nFunctions​\nparse​\nfunction parse(\n  bytes data,\n  string prefix\n) internal returns (string)\n\nParameters:​\nName\tType\tDescription\ndata\tbytes\t\nprefix\tstring\t\nEdit this page\nPrevious\nPermitable\nNext\nLiquidity Source and API\nFunctions\nparse"
  },
  {
    "title": "Quote params | 1inch Network",
    "url": "https://docs.1inch.io/docs/aggregation-protocol/api/quote-params/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nIntroduction\nGuide\nAPI\nLegal\nSwagger\nSwap params\nQuote params\nSmart contracts\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nAggregation ProtocolAPIQuote params\nQuote params\nFind the best quote to exchange via 1inch router: /api/quote​\nDescription of query parameters​\nParameter name\tType\tDescription\nsrc*\tstring\tcontract address of a token to sell\ne.g.: 0x6b175474e89094c44da98b954eedeac495271d0f\ndst*\tstring\tcontract address of a token to buy\ne.g.: 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\namount*\tinteger\tamount of a token to sell, set in minimal divisible units\ne.g.:\n1.00 DAI set as 1000000000000000000\n51.03 USDC set as 51030000\nincludeTokensInfo\tboolean\tif set to true, response will include from token and to token info\ndefault: false\nincludeProtocols\tboolean\tif set to true, response will include protocols used in the quote\ndefault: false\nincludeGas\tboolean\tif set to true, response will include gas limit anticipated for the quote\ndefault: false\nfee\tnumber\tthis percentage of src token amount will be sent to referrerAddress,\nthe rest will be used as input for a swap\nmin: 0; max: 3; default: 0;\nexample to set a fee to 1.5%: &fee=1.5\nprotocols\tstring\tspecify liquidity protocols to use. If not set, all liquidity protocols will be used\ne.g.: &protocols=WETH,CURVE,BALANCER,...,ZRX\ndefault: all protocols can be used\ngasPrice\tstring\t1inch takes in account gas expenses to determine exchange route. It is important to use the same gas price\non the quote and swap methods\ngas price set in wei: 12.5 GWEI set as 12500000000\ndefault: \"fast\" from the network\ncomplexityLevel\tstring\tmaximum number of token-connectors to be used in a transaction. The more is used — the longer route estimation will take, the more complex route might be as a result. If not set, two token-connectors might be used\nmin: 0; max: 3; default: 2\nconnectorTokens\tstring\ttoken-connectors can be specified via this parameter. The more is set — the longer route estimation will take. If not set, default token-connectors will be used. If token you want to exchange doesn't have a pool with one of the default token-connectors, this parameter will help find the route; should be the same for a quote and swap e.g.:\n&connectorTokens=0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, 0x6b175474e89094c44da98b954eedeac495271d0f\ndefault: list of default token-connectors\ngasLimit\tinteger\tmaximum amount of gas for a swap;\nshould be the same for a quote and swap\ndefault: 11500000; max: 11500000;\nmainRouteParts\tinteger\tlimit maximum number of main route parts;\nshould be the same for a quote and swap\ndefault: 20; max: 50;\nparts\tinteger\tlimit maximum number of parts each main route part can be split into; should be the same for a quote and swap\ndefault: 20; max: 100;\nDescription of response parameters​\nParameter name\tType\tDescription\nfromToken\tstring\tparameters of a token to sell\ntoToken\tstring\tparameters of a token to buy\nfromAmount\tstring\tinput amount of fromToken in minimal divisible units\ntoAmount\tstring\tresult amount of toToken in minimal divisible units\nprotocols\tstring\troute of the trade\ngas\tstring\trough estimated amount of the gas limit for used protocols;\ndo not use gas from the quote method as the gas limit of a transaction\nEdit this page\nPrevious\nSwap params\nNext\nAggregationRouterV5\nFind the best quote to exchange via 1inch router: /api/quote\nDescription of query parameters\nDescription of response parameters"
  },
  {
    "title": "Legal | 1inch Network",
    "url": "https://docs.1inch.io/docs/aggregation-protocol/api/legal/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nIntroduction\nGuide\nAPI\nLegal\nSwagger\nSwap params\nQuote params\nSmart contracts\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nAggregation ProtocolAPILegal\nLegal\n\nThe 1inch API, Pathfinder, is a cutting-edge discovery and routing algorithm, which offers asset exchanges at the best rates on the market. Pathfinder finds the most efficient paths for a token swap, able to split between different protocols and even different market depths in within one protocol in the shortest possible time. These API Licence Agreement govern your access to and use of the 1inch API. You must read the Agreement carefully.\n\nLicense\n\nEdit this page\nPrevious\nQuick start\nNext\nSwagger"
  },
  {
    "title": "Swap params | 1inch Network",
    "url": "https://docs.1inch.io/docs/aggregation-protocol/api/swap-params/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nIntroduction\nGuide\nAPI\nLegal\nSwagger\nSwap params\nQuote params\nSmart contracts\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nAggregation ProtocolAPISwap params\nSwap params\nCAUTION\n\nThe public Swap API api.1inch.io is deprecated. To continue using the Swap API please migrate to the 1inch Developer Portal\n\nGenerate data for calling the 1inch router for exchange: /api/swap​\nDescription of query parameters​\nParameter name\tType\tDescription\nsrc *\tstring\tcontract address of a token to sell\ne.g.: 0x6b175474e89094c44da98b954eedeac495271d0f\ndst *\tstring\tcontract address of a token to buy\ne.g.: 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\namount *\tinteger\tamount of a token to sell, set in minimal divisible units e.g.:\n1.00 DAI set as 1000000000000000000\n51.03 USDC set as 51030000\nfrom *\tstring\taddress of a seller, make sure that this address has approved to spend src in needed amount\ne.g.: 0x52bc44d5378309ee2abf1539bf71de1b7d7be3b5\nslippage *\tnumber\tlimit of price slippage you are willing to accept in percentage, may be set with decimals. &slippage=0.5 means 0.5% slippage is acceptable. Low values increase chances that transaction will fail, high values increase chances of front running. Set values in the range from 0 to 50\nprotocols\tstring\tspecify liquidity protocols. If not set, all liquidity protocols will be used; you can disable any protocol by listing all protocols except those you don't need\ne.g.: &protocols=WETH,CURVE,BALANCER,...,ZRX\ndefault: all protocols can be used\nreceiver\tstring\trecipient address of a purchased token\nif not set, from will receive a purchased token\nincludeTokensInfo\tboolean\tif set to true, response will include from token and to token info\ndefault: false\nincludeProtocols\tboolean\tif set to true, response will include protocols used in the quote\ndefault: false\nreferrer\tstring\treferrer's address\nfee\tnumber\tthis percentage of src token amount will be sent to referrer, the rest will be used as input for a swap\nmin: 0; max: 3; default: 0\nexample to set a fee to 1.5%: &fee=1.5\ngasPrice\tstring\t1inch takes in account gas expenses to determine exchange route. It is important to use the same gas price on the quote and swap methods.\nGas price set in wei: 12.5 GWEI set as 12500000000\ndefault: \"fast\" from network\npermit\tstring\thttps://eips.ethereum.org/EIPS/eip-2612\ncompatibility\tboolean\tIf true, the swap function will always be used. This helps when the token being traded has a tax or fee on trade or transfer\ndefault: false\ncomplexityLevel\tstring\tmaximum number of token-connectors to be used in a transaction. The more is used — the longer route estimation will take, the more complex route might be as a result. If not set, two token-connectors may be used\nmin: 0; max: 3; default: 2\nconnectorTokens\tstring\ttoken-connectors can be specified via this parameter. The more is set — the longer route estimation will take. If not set, default token-connectors will be used. If a token you want to exchange doesn't have a pool with one of the default token-connectors this parameter will help find the route; should be the same for a quote and swap max: 5;\ne.g.: &connectorTokens=0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE, 0x6b175474e89094c44da98b954eedeac495271d0f\ndefault: list of default token-connectors\nallowPartialFill\tboolean\tif true, the algorithm can cancel part of the route, if the rate has become less attractive. Unswapped tokens will return to the from\ndefault: true\ndisableEstimate\tboolean\tif true, disable most of the checks\ndefault: false\ngasLimit\tinteger\tmaximum amount of gas for a swap;\nshould be the same for a quote and swap\ndefault: 11500000; max: 11500000\nmainRouteParts\tinteger\tlimit maximum number of main route parts;\nshould be the same for a quote and swap\ndefault: 20; max: 50\nparts\tinteger\tlimit maximum number of parts each main route parts can be split into; should be the same for a quote and swap\ndefault: 20; max: 100\nDescription of response parameters​\nBy default only toAmount and the tx object are returned​\nParameter name\tType\tDescription\nfromToken\tstring\tparameters of a token to sell\ntoToken\tstring\tparameters of a token to buy\nfromAmount\tstring\tinput amount of fromToken in minimal divisible units\ntoAmount\tstring\tresult amount of toToken in minimal divisible units\nprotocols\tstring\troute of the trade\nfrom\tstring\ttransactions will be sent from this address\nto\tstring\ttransactions will be sent to our contract address\ndata\tstring\tbytes of call data\nvalue\tstring\tamount of ETH (in wei) will be sent to the contract address\ngasPrice\tstring\tgas price in wei\ngas\tstring\testimated amount of the gas limit, increase this value by 25%\nEdit this page\nPrevious\nSwagger\nNext\nQuote params\nGenerate data for calling the 1inch router for exchange: /api/swap\nDescription of query parameters\nDescription of response parameters"
  },
  {
    "title": "1IPs | 1inch Network",
    "url": "https://docs.1inch.io/docs/governance/1IPs/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nOverview\nProposal Lifecycle\nVoting Process\n1inch Network DAO Treasury\nInstant Governance\n1inch Improvement Proposal (1IP) Template\n1IPs\nGlossary\nEducational Resources\nGovernance1IPs\n1IPs\n\nThis section tracks all 1IPs that have made it to the Phase-4: Snapshot Vote of the Proposal Lifecycle.\n\nPassed​\n\nAll 1IPs that have successfully passed the Phase-4 vote. These 1IPs have already been implemented or are in the process of being implemented:\n\n[1IP-40] StableLab Grant Request for developing a 1inch DAO Constitution​\n[1IP-39][Fast Track] Deploy 1inch Network Protocols on Coinbase's Base​\n[1IP-37] Gitcoin LatAm Featured Round​\n[1IP-35] Amendment to the Recognized delegates program​\n[1IP-34] 1inch Events Grant Proposal​\n[1IP-33] Implement Dynamic Fusion Mode Resolver Whitelist Based on Unicorn Power Threshold​\n[1IP-31] 1inch Community Builders Program​\n[1IP-30] 1inch Hardware Wallet production completion\n[1IP-29] Recognised delegates program​\n[1IP-28] Discontinue Swap Surplus Collection​\n[1IP-27] Allocate 1M USDC stables in treasury to lending pool on AAVE V3​\n[1IP-26] Remove st1INCH(v1) Voting | Modify st1INCH(v2) and v1INCH Voting Weight Calculations​\n[1IP-25][Fast-Track] Deploy 1inch Fusion Mode on Multiple Networks​\n[1IP-24][Fast-Track] Deploy 1inch Network Protocols on zkSync Era​\n[1IP-21] 1inch NFT Marketplace MVP​\n[1IP-20] 1INCH Fast Track Proposal​\n[1IP-19] Increase the Number of Whitelisted Fusion Mode Resolver to 10​\n[1IP-18] 1inch Analytics Dashboard​\n[1IP-17] 1inch DAO Donation to Humanitarian Relief Efforts in Turkiye​\n[1IP-16] Community Governance Incentives​\n[1IP-15] Update 1inch DAO Voting Process to Include ‘Abstain’ option​\n[1IP-14] Update 1inch DAO Voting Process to Include st1INCH(v2)​\n[1IP-13] Governance Process Improvements​\n[1IP-12] Improve Fusion Auction Resolver Competition​\n[1IP-11] 1inch Staking Pods​\n[1IP-09] Collect 1inch DAO Treasury Revenue in 1INCH Token in Addition to USDC​\n[1IP-08] Simple diversification mechanism for 1inch DAO Treasury​\n[1IP-07] Integrate Balancer Boosted Pools in the 1inch Aggregation Protocol​\n[1IP-05] Add Derivative Aggregation to 1inch Network​\nNot-Passed​\n\nAll 1IPs that did not pass the Phase-4 vote. These 1IPs did not meet the minimum quorum, and/or a majority of the voting weight was opposed to the change:\n\n[1IP-38] Reduce 1inch Governance Quorum to 7m Unicorn Power (UP)​\n[1IP-36] Creating reviews, threads, articles, and natively working with DeFi opinion leaders​\n[1IP-32] StableLab 1INCH Grant Request​\n[1IP-23] Allocate $900,000 in $ARB to Purchase a Lamborghini Revuelto for Marketing Purposes​\n[1IP-22] A Community First 1inch DAO NFT Marketplace​\n[1IP-10] 1inch DAO SAFE Airdrop Claim​\n[1IP-06] Donation of 1inch DAO Treasury Funds to support Ukraine’s humanitarian crisis​\n[1IP-03] VOTE to make $1INCH deflationary!​\n[1IP-01] 1inch Trading Incentives - Discount, Swap Fee & Slippage Subsidies​\nEdit this page\nPrevious\n1inch Improvement Proposal (1IP) Template\nNext\nGlossary\nPassed\n1IP-40 StableLab Grant Request for developing a 1inch DAO Constitution\n1IP-39 Deploy 1inch Network Protocols on Coinbase's Base\n1IP-37 Gitcoin LatAm Featured Round\n1IP-35 Amendment to the Recognized delegates program\n1IP-34 1inch Events Grant Proposal\n1IP-33 Implement Dynamic Fusion Mode Resolver Whitelist Based on Unicorn Power Threshold\n1IP-31 1inch Community Builders Program\n1IP-29 Recognised delegates program\n1IP-28 Discontinue Swap Surplus Collection\n1IP-27 Allocate 1M USDC stables in treasury to lending pool on AAVE V3\n1IP-26 Remove st1INCH(v1) Voting | Modify st1INCH(v2) and v1INCH Voting Weight Calculations\n1IP-25 Deploy 1inch Fusion Mode on Multiple Networks\n1IP-24 Deploy 1inch Network Protocols on zkSync Era\n1IP-21 1inch NFT Marketplace MVP\n1IP-20 1INCH Fast Track Proposal\n1IP-19 Increase the Number of Whitelisted Fusion Mode Resolver to 10\n1IP-18 1inch Analytics Dashboard\n1IP-17 1inch DAO Donation to Humanitarian Relief Efforts in Turkiye\n1IP-16 Community Governance Incentives\n1IP-15 Update 1inch DAO Voting Process to Include ‘Abstain’ option\n1IP-14 Update 1inch DAO Voting Process to Include st1INCH(v2)\n1IP-13 Governance Process Improvements\n1IP-12 Improve Fusion Auction Resolver Competition\n1IP-11 1inch Staking Pods\n1IP-09 Collect 1inch DAO Treasury Revenue in 1INCH Token in Addition to USDC\n1IP-08 Simple diversification mechanism for 1inch DAO Treasury\n1IP-07 Integrate Balancer Boosted Pools in the 1inch Aggregation Protocol\n1IP-05 Add Derivative Aggregation to 1inch Network\nNot-Passed\n1IP-38 Reduce 1inch Governance Quorum to 7m Unicorn Power (UP)\n1IP-36 Creating reviews, threads, articles, and natively working with DeFi opinion leaders\n1IP-32 StableLab 1INCH Grant Request\n1IP-23 Allocate $900,000 in $ARB to Purchase a Lamborghini Revuelto for Marketing Purposes\n1IP-22 A Community First 1inch DAO NFT Marketplace\n1IP-10 1inch DAO SAFE Airdrop Claim\n1IP-06 Donation of 1inch DAO Treasury Funds to support Ukraine’s humanitarian crisis\n1IP-03 VOTE to make $1INCH deflationary!\n1IP-01 1inch Trading Incentives - Discount, Swap Fee & Slippage Subsidies"
  },
  {
    "title": "Glossary | 1inch Network",
    "url": "https://docs.1inch.io/docs/governance/Glossary/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nOverview\nProposal Lifecycle\nVoting Process\n1inch Network DAO Treasury\nInstant Governance\n1inch Improvement Proposal (1IP) Template\n1IPs\nGlossary\nEducational Resources\nGovernanceGlossary\nGlossary\n1INCH​\n\nAn ERC-20 token that is used to participate in the 1inch DAO governance process.\n\nst1INCH: An ERC-20 which represents 1INCH staked with the 1inch protocol.\nv1INCH: An ERC-20 which represents 1INCH tokens that are currently locked in the vesting contract. v1INCH has voting power based on the token's vesting schedule -- emulating the power decay of Unicorn Power obtained by st1INCH.\n1IP​\n\n1inch Improvement Proposal, 1IP, is the title given to proposals that have reached the Phase 4 Snapshot vote.\n\n1RC​\n\n1inch Request for Comment, 1RC, is the title given to formalized proposals.\n\nDAO​\n\nA decentralized autonomous organization.\n\nDelegation​\n\nst1INCH and v1INCH holders can delegate their voting rights to any address. Delegation does not lock the tokens, and the delegator has the power to revoke this delegation at any time. Vote delegation is an on-chain event.\n\nDelegator: The governance token holder that has delegated their voting power to another address.\nDelegatee: The address that has been delegated voting power from any number of delegators.\nDocusaurus​\n\nThe tool used to build 1inch DAO’s documentation site. Docusaurus is similar to GitBook, however Docusaurus has an unencumbered free-use MIT license.\n\nOff-chain​\n\nAn event that does not occur on the blockchain. Off-chain events are gasless.\n\nOn-chain​\n\nAn event that is recorded and verified by the blockchain. All on-chain transactions incur fees paid to miners/validators.\n\nQuorum​\n\nIn order for a snapshot vote to pass, it must achieve a quorum of 10 million 1INCH votes. The purpose of the quorum is to ensure adequate voter participation for all proposals passed.\n\nSnapshot​\n\nSnapshot is the protocol that allows users to vote on proposals in a gasless fashion.\n\nStaking contract​\n\nThe smart-contract that governance participants use to stake their 1INCH.\n\nSwap Surplus​\n\nThe Swap Surplus is generated by swap transactions when the executed price is slightly better than the price quoted.\n\nTimelock​\n\nAll governance actions passed with the voting process will have a time delay of 72 hours before they are incorporated. This applies to funds spent from the DAO Treasury, and any change to the 1inch Protocol’s smart contracts.\n\nVoting​\n\nVoting is the formal process of passing or failing 1IPs. Voting is done through Snapshot — gasless off-chain voting using the on-chain balances of st1INCH and v1INCH.\n\nVoting Period​\n\nAll Snapshot votes will have a voting period of seven days for 1inch DAO members to cast their vote.\n\nUnicorn Power (UP)​\n\nUnicorn Power (UP) is earned by staking 1INCH tokens and represents your influence within the 1inch DAO governance and Fusion mode delegation processes. The amount of Unicorn Power held decreases over time. It can be delegated to 1inch Fusion Resolvers and governance delegates in the 1inch Snapshot Space. This is sometimes referred to as \"Voting Weight\".\n\nEdit this page\nPrevious\n1IPs\nNext\nIntroduction\n1INCH\n1IP\n1RC\nDAO\nDelegation\nDocusaurus\nOff-chain\nOn-chain\nQuorum\nSnapshot\nStaking contract\nSwap Surplus\nTimelock\nVoting\nVoting Period\nUnicorn Power (UP)"
  },
  {
    "title": "1inch Improvement Proposal (1IP) Template | 1inch Network",
    "url": "https://docs.1inch.io/docs/governance/improvement-proposal-template/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nOverview\nProposal Lifecycle\nVoting Process\n1inch Network DAO Treasury\nInstant Governance\n1inch Improvement Proposal (1IP) Template\n1IPs\nGlossary\nEducational Resources\nGovernance1inch Improvement Proposal (1IP) Template\n1inch Improvement Proposal (1IP) Template\nTitle​\n\nTitle should reflect the content of the 1IP.\n\nFor the forum post, prefix “[1RC]” to the title and set the tag on the post to phase-2. Proposals will be assigned an 1IP-# at the time of Phase 4 Snapshot creation.\n\nSimple Summary​\n\nA brief, high-level summary of what changes are being suggested. Summary should be a single sentence, or a bulleted list.\n\nAbstract​\n\nAbstract is a multi-sentence (short paragraph) technical summary. This should be a very terse and human-readable version of the motivation and specification sections. Someone should be able to read only the abstract to get the gist of what this specification does.\n\nMotivation​\n\nThe motivation section should describe the \"why\" of this 1IP. What problem does it solve? Why should someone want to implement this standard? What benefit does it provide to the 1inch Network or protocols? What use cases does this 1IP address?\n\nSpecification​\n\nThe specification section should describe the syntax and semantics of any new feature, or change, at a technical level. The specification should be detailed enough to allow for implementation by a development team.\n\nRationale​\n\nThe rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered, and explain why the proposed specification provides the most amount of net benefit.\n\nConsiderations​\n\nAll 1IPs must contain a section that discusses the security and governance implications/considerations of the proposal.\n\nSecurity specific implications/considerations include security-relevant design decisions, concerns, implementation-specific guidance and pitfalls, drawbacks, an outline of threats and risks and how they are being addressed, etc.\n\nGovernance specific implications/considerations include impact on revenue stream, cost to treasury, voting process, staking, tokenomics, etc.\n\nIf the proposal requires payment to a third party team, this section must contain the qualifications of said team.\n\nEdit this page\nPrevious\nInstant Governance\nNext\n1IPs\nTitle\nSimple Summary\nAbstract\nMotivation\nSpecification\nRationale\nConsiderations"
  },
  {
    "title": "Instant Governance | 1inch Network",
    "url": "https://docs.1inch.io/docs/governance/instant-governance/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nOverview\nProposal Lifecycle\nVoting Process\n1inch Network DAO Treasury\nInstant Governance\n1inch Improvement Proposal (1IP) Template\n1IPs\nGlossary\nEducational Resources\nGovernanceInstant Governance\nInstant Governance\n\nInstant Governance is a feature that allows the community to vote for specific protocol settings. The Aggregation Protocol and Liquidity Protocol each have their own Instant Governance module.\n\nAggregation Protocol Instant Governance​\n\nThe Aggregation Protocol Instant Governance module allows community members to vote on how the Swap Surplus revenue stream is split between the Treasury and the referrers.\n\nLiquidity Protocol Instant Governance​\n\nThe Liquidity Protocol Instant Governance module allows the community to vote directly on major Liquidity Protocol parameters: the price impact fee, the swap fee, the Treasury accrual rate, the referral reward, and the decay period.\n\nThere are two levels of Liquidity Protocol Instance Governance:\n\nPool governance only allows for the configuration of parameters specific to each pool. These parameters include the swap fee, the price impact fee, and the decay period. Liquidity providers may participate in pool governance by using that pool's LP tokens -- the weight of each user’s vote is proportional to the amount of LP tokens they have. The Liquidity Protocol uses a weighted average of all votes and applies it linearly over 24 hours.\n\nFactory governance is responsible for parameters shared by all pools. These include the default swap fee, the default price impact fee, the default decay period, the referral reward and the Treasury accrual rate.\n\nDecay period​\n\nThe decay period is a unique feature that protects traders from front-running attacks and prevents arbitrage traders from easily extracting value from pools. Longer decay periods lead to a wider price spread in the pool after trades. 1INCH stakers can set a decay period between 15 seconds and 1 hour.\n\nReferral reward​\n\nThis reward is a part of the swap fee and the price impact fee which will be dedicated to referrers (dApps and wallets that attract users and trading volume). Referrers can subsequently claim their share of 1INCH tokens from all pools in one gas-efficient claim transaction.\n\nTreasury accrual rate​\n\nAll protocol revenue not sent to the referrers is instead sent to the Treasury.\n\nEdit this page\nPrevious\n1inch Network DAO Treasury\nNext\n1inch Improvement Proposal (1IP) Template\nAggregation Protocol Instant Governance\nLiquidity Protocol Instant Governance\nDecay period\nReferral reward\nTreasury accrual rate"
  },
  {
    "title": "Voting Process | 1inch Network",
    "url": "https://docs.1inch.io/docs/governance/voting-process/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nOverview\nProposal Lifecycle\nVoting Process\n1inch Network DAO Treasury\nInstant Governance\n1inch Improvement Proposal (1IP) Template\n1IPs\nGlossary\nEducational Resources\nGovernanceVoting Process\nVoting Process\nVoting Weight​\n\n1inch Protocol is controlled by the 1inch governance tokens. To ensure that the individuals with direct control over the protocol have a vested interest in its long term success, while also limiting the power of backers and core contributors, different voting weights were assigned to each class of governance token:\n\n1INCH: The un-staked version of 1INCH does not have the ability to vote on governance proposals. It must first be staked.\nst1INCH: This is the non-transferable ERC-20 which represents 1INCH staked within the 1inch protocol’s governance contract. With the implementation of 1IP-11 staking is now time-locked with a maximum lock period of 2-years. Unicorn Power, a.k.a. Voting Weight, is obtained by staking 1INCH.\nv1INCH: This is an ERC-20 which represents 1INCH tokens that are currently locked in the vesting contract. These tokens are held by backers, advisors, and core contributors but are not yet fully-vested. With the implementation of 1IP-26, v1INCH voting weight emulates the power decay of Unicorn Power -- i.e., fully vested, and unclaimed, v1INCH, has greatly diminished voting power. v1INCH that is at the beginning of its vesting contract has full 1:1 voting parity with st1INCH that is at the beginning of a 2-year lock.\nUnicorn Power (UP) This represents an individual's influence within the 1inch DAO governance process. Unicorn Power is earned by staking 1INCH tokens. The amount of Unicorn Power held decreases over time.\nStaking​\n\n1INCH must be staked in the governance contract to participate in voting. Staking is an on-chain event in which the user temporarily locks their 1INCH up and receives non-transferable st1INCH. With the impelementation of 1IP-11, staking is a time-locked event with minimum and maximum lock periods chosen by the DAO -- at the time of writing this those staking periods are 1-month and 2-years respectively. Uses may may reverse the process by using the Unstake token UI. however, there may be early withdrawal penalties.\n\nUnicorn Power (UP) is earned by staking 1INCH tokens and represents your influence within the 1inch DAO governance and Fusion mode delegation processes. The amount of Unicorn Power held decreases over time.\n\nVote Delegation​\n\nIn 1inch Network, delegation is categorized into two distinct types: delegation to Fusion Mode resolvers and Snapshot delegation. Both of these delegation processes involve users allocating their Unicorn Power to different purposes. It is important to note that the same Unicorn Power can be simultaneously delegated to Fusion Mode resolvers as well as in the 1inch Snapshot space, without any conflicts or interference. These two delegation methods operate independently of each other, serving separate functions within the platform: utility and governance. This section focuses on governance delegation via Snapshot, refer to the Fusion swap for information\n\nIndividuals may delegate their Unicorn Power (UP) to an address of their choice. Those who choose to delegate their voting rights to another address are known as Delegators, while those who receive delegation are known as Delegatees. 1inch Network DAO uses Snapshot's supported delegation strategy.\n\nAnybody can participate in 1inch DAO governance if their address has received delegation, even if the address of the delegatee holds no governernance tokens or Unicorn Power.\n\n1inch governance token holders may choose to delegate their voting powers in the Snapshot 1inch space, or, by interacting directly with the Snapshot delegation smart contract. Both locations can also be used to remove delegation from a previously assigned address.\n\nIf a Delegator delegates their voting power to a Delegatee and both of them vote on the same proposal, then the delegated voting power is ignored for that vote. In other words, even if a Delegator has allotted their voting power to another address, said Delegator always has the option to temporarily override that delegation by voting themselves.\n\nSupported Networks​\n\nCurrently, 1inch DAO voting uses governance token balances and delegations on the Ethereum mainnet.\n\n1INCH Token​\n\n1INCH is the governance and utility token of the 1inch Network.\n\nDistribution​\nToken Addresses​\n1INCH​\nEthereum mainnet: 0x111111111117dc0aa78b770fa6a738034120c302\nBinance Smart Chain: 0x111111111117dc0aa78b770fa6a738034120c302\nv1INCH​\nEthereum mainnet: 0x03d1b1a56708fa298198dd5e23651a29b76a16d2\nst1INCH (v1)​\nEthereum mainnet: 0xA0446D8804611944F1B527eCD37d7dcbE442caba\nst1INCH (v2)​\nEthereum mainnet: 0x9A0C8Ff858d273f57072D714bca7411D717501D7\nEdit this page\nPrevious\nProposal Lifecycle\nNext\n1inch Network DAO Treasury\nVoting Weight\nStaking\nVote Delegation\nSupported Networks\n1INCH Token\nDistribution\nToken Addresses"
  },
  {
    "title": "1inch Network DAO Treasury | 1inch Network",
    "url": "https://docs.1inch.io/docs/governance/dao-treasury/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nOverview\nProposal Lifecycle\nVoting Process\n1inch Network DAO Treasury\nInstant Governance\n1inch Improvement Proposal (1IP) Template\n1IPs\nGlossary\nEducational Resources\nGovernance1inch Network DAO Treasury\n1inch Network DAO Treasury\n\nThe 1inch Network DAO Treasury is the pool of funds under the direct domain and ownership of the community.\n\nAll protocol revenues are directed to the DAO Treasury and referral rewards.\n\nDAO Treasury​\n\nThe primary 1inch Network DAO Treasury is a Safe smart contract wallet with multi-signature (multisig) functionality on the Ethereum mainnet. 12 multisig owners have initially been selected by the 1inch Foundation from the core contributor team and other well-known projects, such as Synthetix, Opium, NEAR protocol, and zkSync, to name a few. These signers are able to veto malicious transactions in a 7-of-12 fashion.\n\nSafe + Snapshot + SafeSnap​\n\nSnapshot allows for gasless voting. SafeSnap, also known as Reality Module, is a Snapshot module that allows for on-chain execution of off-chain voting. The combination of these tools gives the DAO’s votes direct control over the Safe that holds the Treasury funds.\n\nSafeSnap has been integrated into the 1inch Snapshot space. 1IPs that call for payment(s) from the treasury must have the \"Transactions\" container filled out by the individual proposing the Phase 4 Snapshot vote. Required fields include transaction type, Asset, recipient address, and amount.\n\nOnce the Snapshot vote closes, and the vote has met the minimum quorum (more in Phase 4: Snapshot Vote), anyone can use the Snapshot UI to \"Request execution\" in the \"SafeSnap Execution\" window -- this is an on-chain transaction that initializes the reality.eth Oracle.\n\nAfter the reality.eth Oracle has been initialized, anyone can set the outcome by putting up a bond of 0.1 ETH to be used in the escalation-game-based Oracle. This bond is returned if their answer correctly identifies the passing result of the Snapshot proposal as specified in the 1inch Network DAO Acceptance Criteria.\n\nThe bonded escalation game concludes once a 72-hour period has elapsed without challenge. Challenging the outcome requires a bond that is at least double the size of the current one, and it restarts the 72-hour period.\n\nOnce the reality.eth bonded oracle resolves in favor of the proposal, there is an additional 72 hour period of time between the SafeSnap resolution and the ability for the underlying transaction to be executed -- this is known as the Timelock. During the Timelock period, the 1inch Network DAO Treasury multisig owners will have the ability to veto malicious transactions in a 7-of-12 fashion.\n\nAfter all steps have successfully completed, the proposal will be executable by anyone who calls the function. The reality.eth participants may then retrieve their bond.\n\nKleros Arbitration​\n\nThe Kleros DAO Governance Arbitrator is set as the default Anyone can request Kleros arbitration for the reality.eth bonded escalation game at any point after the first answer is submitted. This can be done in the reality.eth app or by interacting directly with the smart contract. Once arbitration is called, the bonded escalation is paused and no further answers are accepted.\n\nKleros Oracle combines Kleros's dispute resolution court system with reality.eth's cryptoeconomic bonded escalation game for verifying off-chain events on-chain. The Kleros DAO Governance Arbitrator acts as a proxy between reality.eth and Kleros Court contract. It creates a corresponding dispute in Kleros Courts and submits the final ruling as an answer in the proper reality.eth format. There are 5 votes in the DAO Governance Arbitrator subcourt, each vote has a juror fee of 0.072 ETH, so the total cost of arbitration is 0.36 ETH (fee numbers are from the October 2021 Kleros Pramater Update vote and are subject to change).\n\nIf the result of the Kleros arbitration is to affirm the answer given by the final answerer, that person receives the question reward. If the result of arbitration is to change the final answer, the individual who paid for arbitration receives the question reward.\n\n1inch DAO Treasury Addresses​\nNetwork\tAddress\tNotes\nEthereum\teth:0x7951c7ef839e26F63DA87a42C9a87986507f1c07\tPrimary DAO treasury. SafeSnap allows for trustless execution of spending proposals.\nEthereum\teth:0x45e84e10e8E85c583C002A40007D10629EF80fAF\t1inch DAO operations fund. This is a 3-of-4 multisig.\nArbitrum\tarb1:0x71890aC6209Fae61E9D66691c47B168B8300a7c5\t\nGnosis Chain\tgno:0x422B530b30210A1A4C77Bf1aDCd3352b0DfbCDc0\t\nPolygon\tmatic:0x0A777DCD3F7924AD769aB2026b2Bb377bD08F4CA\t\nAurora\taurora:0x32865f542bE59b39dEAD7FAda7555734c3305786\t\nAvalanche\tavax:0x5ef96E97e25dB95B906d56A0A517a6c407FD4083\t\nOptimism\toeth:0xdCBc42C20B7296BfEA6E47b8D88AdD4f69a6DCCB\t\nBNB Chain\tbnb:0xb946a9FD3935F3A6364F822e814a15E14b841e67\t\n\nNote: Unless otherwise noted, all 1inch DAO treasuries have the same 12 signers, and 7-of-12 threshold, as the primary treasury on Ethereum mainnet.\n\nRevenue stream​\n\nThe 1inch Pathfinder algorithm always provides users the most current and best possible prices on a swap. However, the swap price sometimes moves between the time of the quote and the time that the transaction is mined — resulting in a Swap Surplus.\n\nFunds are collected from the Swap Surplus on all chains. A portion of these funds are paid out to the referral program on the chain the swaps were performed. The majority are sent to the Ethereum mainnet, swapped for USDC, and sent directly to the 1inch Network DAO Treasury.\n\nGovernance participants are able to control the revenue split of the Aggregation Protocol and Liquidity protocol by voting with Instant Governance.\n\nNote that none of the revenue funds ever go to the 1inch Foundation -- they are 100% controlled by the 1inch DAO.\n\nExternal References​\n1inch DAO reality.eth module -- 0xa62D2a75eb39C12e908e9F6BF50f189641692F2E\n1inch DAO Acceptance Criteria -- IPFS deployment\nreality.eth:\nApp\nWhitepaper\nReality Module Governance Oracle Question Resolution Policy\nKleros:\nDocumentation site\nDAO Governance Arbitrator Github\nKleros DAO Governance Arbitrator Proxy -- 0xf72CfD1B34a91A64f9A98537fe63FBaB7530AdcA\nEdit this page\nPrevious\nVoting Process\nNext\nInstant Governance\nDAO Treasury\nSafe + Snapshot + SafeSnap\nKleros Arbitration\n1inch DAO Treasury Addresses\nRevenue stream\nExternal References"
  },
  {
    "title": "Proposal Lifecycle | 1inch Network",
    "url": "https://docs.1inch.io/docs/governance/proposal-lifecycle/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nOverview\nProposal Lifecycle\nVoting Process\n1inch Network DAO Treasury\nInstant Governance\n1inch Improvement Proposal (1IP) Template\n1IPs\nGlossary\nEducational Resources\nGovernanceProposal Lifecycle\nProposal Lifecycle\n\nThe 1inch Network DAO governance process takes place in the governance forum at gov.1inch.io. Proposals are formally ratified through the 1inch Improvement Proposal (1IPs). There are no requirements for participating in the 1inch Network DAO discussion. Anyone can sign up for the 1inch Governance forum, or Discord, and engage in the conversation.\n\nPhase 1: Discussion​\n\nThe purpose of this phase is to vet ideas with the broader 1inch community. Each unique idea should have its own thread so that the conversation can stay on topic, it should be as narrowly focused as possible. Anyone can participate in this phase of governance, and it occurs entirely off-chain. The goal of Phase-1 discussion is to gain a rough community consensus, and refine the idea so that it can be formalized. The thread author should make an effort to address all comments and take them into consideration.\n\nForum tag: phase-1\n\nDuration: Open-Ended\n\nPhase 2: 1IP Formalization​\n\nPhase 2 is where the idea is formalized into an 1IP that includes all of the criteria specified in the 1inch Improvement Proposal (1IP) Template. It must be a clear and complete description of the proposed enhancement. It is a requirement that a single 1IP contains a single proposal. All 1IPs must have the following components (refer to the template for a detailed breakdown):\n\nSimple Summary\nAbstract\nMotivation\nSpecification\nRationale\nConsiderations\n\nThe forum is the formal arena to debate the merits of each 1IP. Once the 1IP has been drafted, the author must post it on the 1inch governance forum and use the tag: phase-2.\n\nWhile the 1IP is in a draft state, the 1IP author is free to make modifications to the proposal based on feedback from the community's review.\n\nTo preserve the number sequencing of 1IPs, proposals should use the 1RC (1inch Request for Comment) prefix for both Phase 2 and Phase 3. The 1IP number will be assigned once the proposal enters the Phase-4 Snapshot vote.\n\nForum tag: phase-2\n\nDuration: Open-Ended\n\nPhase 3: 1IP Temperature Check​\n\nAt any point during Phase-2, the author may finalize the 1IP by initiating a community temperature check. To do this, the author must change the tag of the forum post to phase-3, and add a forum poll to gauge the community’s sentiment.\n\n1IPs should only be progressed to Phase-3 once the author has considered all community comments and believes the 1IP is prepared for incorporation. Phase-3 represents the final proposal. Other than correcting errata, 1IPs in Phase 3 may not be edited.\n\nThe poll must be open for 3 days and only have the following options:\n\n(Yes) In favor of this proposal.\n(No) Against this proposal.\n\nOnly successful Phase-3 proposals may progress to Phase-4. In order for a Phase-3 vote to be considered successful, a majority of the temperature check votes cast must be in favor. There is no minimum quorum required for this phase.\n\nForum tag: phase-3\n\nDuration: Exactly 3 days\n\nPhase 4: Snapshot Vote​\n\nAll 1IPs are confirmed, or rejected, by the 1inch Network DAO via an off-chain Snapshot vote. The Snapshot vote must link to the results of the successful Phase-3 forum poll and include the full text of the finalized 1IP. Anyone can initiate the Snapshot vote as long as all requirements of Phase-3 were met (it does not have to be the 1IP author). Once the Snapshot vote has been created, the forum tag should be changed to phase-4 and the title of the post should have the next 1IP-# added as the prefix.\n\nThe Snapshot voting period must last exactly five days. During this period, addresses with voting power may vote for, against or abstain from voting on the proposal using the same three voting options as the Phase-3 poll:\n\n(Yes) In favor of this proposal.\n(No) Against this proposal.\n(Abstain) Neither In favor nor Against\n\nVoting Weight is proportional to the amount of governance tokens held by, or delegated to, an address. To prevent griefing of the 1inch governance process, a minimum of 100,000 Voting Weight is required to create a Snapshot vote.\n\nIn order for a vote to be considered successful, both of the following must be met:\n\nA minimum quorum of 10 million weighted votes must be cast.\nA majority of the votes must be (Yes) I am in favor of this proposal.\n\nSee Voting Process for a detailed description of how Voting Weight is calculated and how Vote Delegation works.\n\nForum tag: phase-4\n\nDuration: Exactly 5 days\n\nPhase 5: Implementation​\n\nAfter the Snapshot voting period has concluded, the results will be posted on 1IPs section of the governance documentation site. If the proposal has passed, it will move from the Active to Passed category. Unsuccessful proposals will move to Not-Passed.\n\nSafeSnap allows for on-chain execution of the off-chain Snapshot vote by using the reality.eth oracle. Reality.eth’s bonded escalation period lasts at least 72 hours (this period is reset if the resolution is challenged). The SafeSnap process officially concludes once a full 72 hour escalation period has elapsed without challenge.\n\nThere is an additional 72 hour period of time between the SafeSnap resolution and the incorporation of said 1IP into the protocol -- this is known as the Timelock. During the Timelock period, the 1inch Network DAO Treasury multisig owners will have the ability to veto malicious transactions in a 7-of-12 fashion.\n\nFor more involved 1IPs, the implementation will vary on a case-by-case basis.\n\nDuration: 6 days, minimum\n\nEdit this page\nPrevious\nOverview\nNext\nVoting Process\nPhase 1: Discussion\nPhase 2: 1IP Formalization\nPhase 3: 1IP Temperature Check\nPhase 4: Snapshot Vote\nPhase 5: Implementation"
  },
  {
    "title": "Switching between networks | 1inch Network",
    "url": "https://docs.1inch.io/docs/rabbithole/switching-between-networks/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nSummary\nFlow\nSwitching between networks\nWallet auto-connect\nGovernance\nEducational Resources\nRabbitholeSwitching between networks\nSwitching between networks\n\nWhen a user selects the RabbitHole option and MetaMask is connected, upon clicking the “Confirm Swap“ button, a pop-up appears with instructions on how to switch between networks. A switch is only possible from MetaMask, but not from the dApp.\n\nSteps that users have to complete to change the network to RabbitHole:​\nOpen MetaMask in the browser panel;\nClick the account and choose “Settings“ from the drop-down menu;\nSelect the “Network“ option;\nClick the “Add Network“ button;\nUse following parameters:\nNetwork name: RabbitHole\nNew RPC URL: https://rabbithole.1inch.io/1\nChain ID: 1\nCurrency symbol: ETH\nBlock explorer URL: https://etherscan.io\nEdit this page\nPrevious\nFlow\nNext\nWallet auto-connect\nSteps that users have to complete to change the network to RabbitHole:"
  },
  {
    "title": "Flow | 1inch Network",
    "url": "https://docs.1inch.io/docs/rabbithole/flow/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nSummary\nFlow\nSwitching between networks\nWallet auto-connect\nGovernance\nEducational Resources\nRabbitholeFlow\nFlow\n\nWhen MetaMask is connected and the network with ID = 1 (Mainnet or RabbitHole) is chosen, the “RabbitHole transaction” option is displayed in the confirmation swap window. When the user selects the “RabbitHole transaction,“ an additional pre-selected option called “Rabbit“ appears in the gas settings:\n\nThe price for a gas unit is twice as high as that for the “Aggressive“ option to make sure that the transaction is successful;\nAll other gas options are also available.\n\nWhen the user hovers over the info icon, the following tooltip is displayed: RabbitHole transactions wouldn't appear in the Ethereum mempool. That protects your transaction from sandwich attacks. RabbitHole transactions require higher fees that are paid directly to the mining pool.\n\nThe front-end can distinguish, to which network MetaMask is connected, the Ethereum Mainnet or the RabbitHole, despite they have the same ID:\n\nAt the moment of MetaMask connection, the dApp sends a viewCall request to the node that interacts with the blockchain (this request only gets information from the blockchain, without making any changes) at the address https://etherscan.io/address/0x0000000000000000000000000000000000000000; request\nDepending on the response, the front-end detects, which network is connected. If the RabbitHole is connected, the response is '0xeeeeeeee';\nEvery 10 seconds, the front-end sends a viewCall request in the background to check if the network hasn’t changed;\nIf the network is detected as “RabbitHole,“ the title is displayed in the network selector instead of Ethereum Mainnet but the icon remains the same as for Ethereum;\nEdit this page\nPrevious\nSummary\nNext\nSwitching between networks"
  },
  {
    "title": "WebSocket API | 1inch Network",
    "url": "https://docs.1inch.io/docs/fusion-swap/fusion-sdk/for-resolvers/websocket-api/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nIntroduction\nBecoming a Resolver\nFusion SDK\nFusion SDK for Integrators\nFusion SDK for Resolvers\nAuction Calculator\nAuction Salt\nAuction Suffix\nWebSocket API\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nFusion swapFusion SDKFusion SDK for ResolversWebSocket API\nWebsocket Api\n\nDescription: provides high level functionality to working with fusion mode\n\nReal world example​\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nwsSdk.order.onOrder((data) => {\n    console.log('received order event', data)\n})\n\nCreation​\n\nWith constructor:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\n\nCustom provider:\n\nUser can provide custom provider for websocket (be default we are using ws library)\n\nimport {WsProviderConnector, WebSocketApi} from '@1inch/fusion-sdk'\n\nclass MyFancyProvider implements WsProviderConnector {\n    // ... user implementation\n}\n\nconst url = 'wss://fusion.1inch.io/ws/v1.0/1'\nconst provider = new MyFancyProvider({url})\n\nconst wsSdk = new WebSocketApi(provider)\n\n\nWith new static method:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = WebSocketApi.new({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\n\nLazy initialization:\n\nBy default when user creates an instance of WebSocketApi, it automatically opens websocket connection which might be a problem for some use cases\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM,\n    lazyInit: true\n})\n\nws.init()\n\nMethods​\n\nBase methods\n\non​\n\nDescription: You can subscribe to any event\n\nArguments:\n\n[0] event: string\n[1] cb: Function\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.on('error', console.error)\n\nws.on('open', function open() {\n    ws.send('something')\n})\n\nws.on('message', function message(data) {\n    console.log('received: %s', data)\n})\n\noff​\n\nDescription: You can unsubscribe from any event\n\nArguments:\n\n[0] event: string\n[1] сb: Function\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.on('error', console.error)\n\nws.on('open', function open() {\n    ws.send('something')\n})\n\nfunction message(data) {\n    console.log('received: %s', data)\n}\n\nws.on('message', message)\n\nws.off('message', message)\n\nonOpen​\n\nDescription: subscribe to open event\n\nArguments:\n\n[0] cb: Function\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.onOpen(() => {\n    console.log('connection is opened')\n})\n\nsend​\n\nDescription: send event to backend\n\nArguments:\n\n[0] message: any message which can be serialized with JSON.stringify\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.send('my message')\n\nclose​\n\nDescription: close connection\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.close()\n\nonMessage​\n\nDescription: subscribe to message event\n\nArguments:\n\n[0] cb: (data: any) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.onMessage((data) => {\n    console.log('message received', data)\n})\n\nonClose​\n\nDescription: subscribe to close event\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.onClose(() => {\n    console.log('connection is closed')\n})\n\nonError​\n\nDescription: subscribe to error event\n\nArguments:\n\n[0] cb: (error: any) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.onError((error) => {\n    console.log('error is received', error)\n})\n\n\nOrder namespace\n\nonOrder​\n\nDescription: subscribe to order events\n\nArguments:\n\n[0] cb: (data: OrderEventType) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.order.onOrder((data) => {\n    if (data.event === 'order_created') {\n        // do something\n    }\n    if (data.event === 'order_invalid') {\n        // do something\n    }\n})\n\nonOrderCreated​\n\nDescription: subscribe to order_created events\n\nArguments:\n\n[0] cb: (data: OrderCreatedEvent) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.order.onOrderCreated((data) => {\n    // do something\n})\n\nonOrderInvalid​\n\nDescription: subscribe to order_invalid events\n\nArguments:\n\n[0] cb: (data: OrderInvalidEvent) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.order.onOrderInvalid((data) => {\n    // do something\n})\n\nonOrderBalanceOrAllowanceChange​\n\nDescription: subscribe to order_balance_or_allowance_change events\n\nArguments:\n\n[0] cb: (data: OrderBalanceOrAllowanceChangeEvent) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.order.onOrderBalanceOrAllowanceChange((data) => {\n    // do something\n})\n\nonOrderFilled​\n\nDescription: subscribe to order_filled events\n\nArguments:\n\n[0] cb: (data: OrderFilledEvent) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.order.onOrderFilled((data) => {\n    // do something\n})\n\nonOrderFilledPartially​\n\nDescription: subscribe to order_filled_partially events\n\nArguments:\n\n[0] cb: (data: OrderFilledPartiallyEvent) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.order.onOrderFilledPartially((data) => {\n    // do something\n})\n\n\nRpc namespace\n\nonPong​\n\nDescription: subscribe to ping response\n\nArguments:\n\n[0] cb: (data: string) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.rpc.onPong((data) => {\n    // do something\n})\n\nping​\n\nDescription: ping healthcheck\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.rpc.ping()\n\ngetAllowedMethods​\n\nDescription: get the list of allowed methods\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.rpc.getAllowedMethods()\n\nonGetAllowedMethods​\n\nDescription: subscribe to get allowed methods response\n\nArguments:\n\n[0] cb: (data: RpcMethod[]) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.rpc.onGetAllowedMethods((data) => {\n    // do something\n})\n\ngetActiveOrders​\n\nDescription: get the list of active orders\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.rpc.getActiveOrders()\n\nonGetActiveOrders​\n\nDescription: subscribe to get active orders events\n\nArguments:\n\n[0] cb: (data: PaginationOutput\\<ActiveOrder>) => void\n\nExample:\n\nimport {WebSocketApi, NetworkEnum} from '@1inch/fusion-sdk'\n\nconst ws = new WebSocketApi({\n    url: 'wss://fusion.1inch.io/ws',\n    network: NetworkEnum.ETHEREUM\n})\n\nws.rpc.onGetActiveOrders((data) => {\n    // do something\n})\n\nTypes​\nOrderEventType​\ntype Event<K extends string, T> = {event: K; data: T}\n\ntype OrderEventType =\n    | OrderCreatedEvent\n    | OrderInvalidEvent\n    | OrderBalanceOrAllowanceChangeEvent\n    | OrderFilledEvent\n    | OrderFilledPartiallyEvent\n\ntype OrderCreatedEvent = Event<\n    'order_created',\n    {\n        orderHash: string\n        signature: string\n        order: LimitOrderV3Struct\n        deadline: string\n        auctionStartDate: string\n        auctionEndDate: string\n        remainingMakerAmount: string\n    }\n>\n\ntype OrderBalanceOrAllowanceChangeEvent = Event<\n    'order_balance_or_allowance_change',\n    {\n        orderHash: string\n        remainingMakerAmount: string\n        balance: string\n        allowance: string\n    }\n>\n\ntype OrderInvalidEvent = Event<\n    'order_invalid',\n    {\n        orderHash: string\n    }\n>\n\ntype OrderFilledEvent = Event<'order_filled', {orderHash: string}>\n\ntype OrderFilledPartiallyEvent = Event<\n    'order_filled_partially',\n    {orderHash: string; remainingMakerAmount: string}\n>\n\nRpcMethod​\ntype RpcMethod = 'getAllowedMethods' | 'ping'\n\nEdit this page\nPrevious\nAuction Suffix\nNext\nIntroduction\nReal world example\nCreation\nMethods\non\noff\nonOpen\nsend\nclose\nonMessage\nonClose\nonError\nonOrder\nonOrderCreated\nonOrderInvalid\nonOrderBalanceOrAllowanceChange\nonOrderFilled\nonOrderFilledPartially\nonPong\nping\ngetAllowedMethods\nonGetAllowedMethods\ngetActiveOrders\nonGetActiveOrders\nTypes\nOrderEventType\nRpcMethod"
  },
  {
    "title": "Examples | 1inch Network",
    "url": "https://docs.1inch.io/docs/spot-price-aggregator/examples/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nExamples\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nSpot Price AggregatorExamples\nExamples\nSingle token-to-ETH price usage​\nconst Web3 = require('web3');\nconst { BigNumber } = require('ethers');\n\nconst yourInfuraKey = 'add your key here';\nconst web3 = new Web3(`https://mainnet.infura.io/v3/${yourInfuraKey}`);\n\n// eslint-disable-next-line max-len\nconst OffChainOracleAbi = '[{\"inputs\":[{\"internalType\":\"contract MultiWrapper\",\"name\":\"_multiWrapper\",\"type\":\"address\"},{\"internalType\":\"contract IOracle[]\",\"name\":\"existingOracles\",\"type\":\"address[]\"},{\"internalType\":\"enum OffchainOracle.OracleType[]\",\"name\":\"oracleTypes\",\"type\":\"uint8[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"existingConnectors\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC20\",\"name\":\"wBase\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"ConnectorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"ConnectorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract MultiWrapper\",\"name\":\"multiWrapper\",\"type\":\"address\"}],\"name\":\"MultiWrapperUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum OffchainOracle.OracleType\",\"name\":\"oracleType\",\"type\":\"uint8\"}],\"name\":\"OracleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum OffchainOracle.OracleType\",\"name\":\"oracleType\",\"type\":\"uint8\"}],\"name\":\"OracleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"addConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"enum OffchainOracle.OracleType\",\"name\":\"oracleKind\",\"type\":\"uint8\"}],\"name\":\"addOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectors\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"allConnectors\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useWrappers\",\"type\":\"bool\"}],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weightedRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useSrcWrappers\",\"type\":\"bool\"}],\"name\":\"getRateToEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weightedRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiWrapper\",\"outputs\":[{\"internalType\":\"contract MultiWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracles\",\"outputs\":[{\"internalType\":\"contract IOracle[]\",\"name\":\"allOracles\",\"type\":\"address[]\"},{\"internalType\":\"enum OffchainOracle.OracleType[]\",\"name\":\"oracleTypes\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"removeConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"enum OffchainOracle.OracleType\",\"name\":\"oracleKind\",\"type\":\"uint8\"}],\"name\":\"removeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MultiWrapper\",\"name\":\"_multiWrapper\",\"type\":\"address\"}],\"name\":\"setMultiWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]';\nconst offChainOracleAddress = '0x07D91f5fb9Bf7798734C3f606dB065549F6893bb';\nconst offChainOracleContract = new web3.eth.Contract(JSON.parse(OffChainOracleAbi), offChainOracleAddress);\n\nconst token = {\n    address: '0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT\n    decimals: 6,\n};\n\noffChainOracleContract.methods.getRateToEth(\n    token.address, // source token\n    true, // use source wrappers\n).call()\n    .then((rate) => {\n        const numerator = BigNumber.from(10).pow(token.decimals);\n        const denominator = BigNumber.from(10).pow(18); // eth decimals\n        const price = BigNumber.from(rate).mul(numerator).div(denominator);\n        console.log(price.toString()); // 472685293218315\n    })\n    .catch(console.log);\n\nMultiple token-to-ETH prices usage​\nconst Web3 = require('web3');\nconst { BigNumber } = require('ethers');\n\nconst yourInfuraKey = 'add your key here';\nconst web3 = new Web3(`https://mainnet.infura.io/v3/${yourInfuraKey}`);\n\n// eslint-disable-next-line max-len\nconst MultiCallAbi = '[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"},{\"internalType\":\"bool[]\",\"name\":\"success\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]';\n// eslint-disable-next-line max-len\nconst OffChainOracleAbi = '[{\"inputs\":[{\"internalType\":\"contract MultiWrapper\",\"name\":\"_multiWrapper\",\"type\":\"address\"},{\"internalType\":\"contract IOracle[]\",\"name\":\"existingOracles\",\"type\":\"address[]\"},{\"internalType\":\"enum OffchainOracle.OracleType[]\",\"name\":\"oracleTypes\",\"type\":\"uint8[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"existingConnectors\",\"type\":\"address[]\"},{\"internalType\":\"contract IERC20\",\"name\":\"wBase\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"ConnectorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"ConnectorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract MultiWrapper\",\"name\":\"multiWrapper\",\"type\":\"address\"}],\"name\":\"MultiWrapperUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum OffchainOracle.OracleType\",\"name\":\"oracleType\",\"type\":\"uint8\"}],\"name\":\"OracleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum OffchainOracle.OracleType\",\"name\":\"oracleType\",\"type\":\"uint8\"}],\"name\":\"OracleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"addConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"enum OffchainOracle.OracleType\",\"name\":\"oracleKind\",\"type\":\"uint8\"}],\"name\":\"addOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectors\",\"outputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"allConnectors\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useWrappers\",\"type\":\"bool\"}],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weightedRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useSrcWrappers\",\"type\":\"bool\"}],\"name\":\"getRateToEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weightedRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiWrapper\",\"outputs\":[{\"internalType\":\"contract MultiWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracles\",\"outputs\":[{\"internalType\":\"contract IOracle[]\",\"name\":\"allOracles\",\"type\":\"address[]\"},{\"internalType\":\"enum OffchainOracle.OracleType[]\",\"name\":\"oracleTypes\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"removeConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"enum OffchainOracle.OracleType\",\"name\":\"oracleKind\",\"type\":\"uint8\"}],\"name\":\"removeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract MultiWrapper\",\"name\":\"_multiWrapper\",\"type\":\"address\"}],\"name\":\"setMultiWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]';\n\nconst offChainOracleAddress = '0x07D91f5fb9Bf7798734C3f606dB065549F6893bb';\n\nconst multiCallContract = new web3.eth.Contract(JSON.parse(MultiCallAbi), '0xda3c19c6fe954576707fa24695efb830d9cca1ca');\nconst offChainOracleContract = new web3.eth.Contract(JSON.parse(OffChainOracleAbi));\n\nconst tokens = [\n    {\n        address: '0x6b175474e89094c44da98b954eedeac495271d0f', // DAI\n        decimals: 18,\n    },\n    {\n        address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC\n        decimals: 6,\n    },\n    {\n        address: '0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT\n        decimals: 6,\n    }, {\n        address: '0x111111111117dc0aa78b770fa6a738034120c302', // 1INCH\n        decimals: 18,\n    },\n];\n\nconst callData = tokens.map((token) => ({\n    to: offChainOracleAddress,\n    data: offChainOracleContract.methods.getRateToEth(\n        token.address,\n        true, // use wrapper\n    ).encodeABI(),\n}));\n\nmultiCallContract.methods.multicall(callData).call()\n    .then(({\n        results,\n        success,\n    }) => {\n        const prices = {};\n        for (let i = 0; i < results.length; i++) {\n            if (!success[i]) {\n                continue;\n            }\n\n            const decodedRate = web3.eth.abi.decodeParameter('uint256', results[i]).toString();\n            const numerator = BigNumber.from(10).pow(tokens[i].decimals);\n            const denominator = BigNumber.from(10).pow(18); // eth decimals\n            const price = BigNumber.from(decodedRate).mul(numerator).div(denominator);\n            prices[tokens[i].address] = price.toString();\n        }\n        console.log(prices);\n        /*\n            {\n                '0x6b175474e89094c44da98b954eedeac495271d0f': '527560209915550',\n                '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': '507746821617073',\n                '0xdac17f958d2ee523a2206206994597c13d831ec7': '529527134930000',\n                '0x111111111117dc0aa78b770fa6a738034120c302': '1048752594621361'\n            }\n         */\n    })\n    .catch(console.log);\n\nEdit this page\nPrevious\nLiquidity Source and API\nNext\nSpot Price Aggregator\nSingle token-to-ETH price usage\nMultiple token-to-ETH prices usage"
  },
  {
    "title": "1inch limit order protocol | 1inch Network",
    "url": "https://docs.1inch.io/docs/limit-order-protocol/smart-contract/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nIntroduction\nLimit vs. RFQ Orders\nOrder creation examples\nJS Utils\nBreaking changes in V3\nSmart contracts\nLimitOrderProtocol\nLimitOrderProtocolPro\nOrderLib\nOrderMixin\nOrderRFQMixin\nTable of contents\nhelpers\ninterfaces\nlibraries\nLiquidity Source and API\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nLimit order protocolSmart contracts\n1inch limit order protocol\n\nhttps://github.com/1inch/limit-order-protocol\n\nEdit this page\nPrevious\nBreaking changes in V3\nNext\nLimitOrderProtocol"
  },
  {
    "title": "Breaking changes in V3 | 1inch Network",
    "url": "https://docs.1inch.io/docs/limit-order-protocol/v3-migration/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nIntroduction\nLimit vs. RFQ Orders\nOrder creation examples\nJS Utils\nBreaking changes in V3\nSmart contracts\nLiquidity Source and API\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nLimit order protocolBreaking changes in V3\nBreaking changes in V3\nLimit Order Protocol itself changes​\nNow contract is pubshed to npm as @1inch/limit-order-protocol\n\nOrder struct has changed as following:\n\nstruct Order {\n    uint256 salt;\n    address makerAsset;\n    address takerAsset;\n    address maker;\n    address receiver;\n    address allowedSender;  // equals to Zero address on public orders\n    uint256 makingAmount;\n    uint256 takingAmount;\n\n-   // Was in v2\n-   // bytes makerAssetData;\n-   // bytes takerAssetData;\n-   // bytes getMakingAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n-   // bytes getTakingAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n-   // bytes predicate;       // this.staticcall(bytes) => (bool)\n-   // bytes permit;          // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n-   // bytes interaction;\n\n+   // Now in v3\n+   uint256 offsets;\n+   bytes interactions; // concat(makerAssetData, takerAssetData, getMakingAmount, getTakingAmount, predicate, permit, preIntercation, postInteraction)\n}\n\n\nwhere offset is bytes, where every 32's bytes represents offset of the n'ths interaction.\n\nEg: for [2, 4, 6] offsets:\n\n(2n << 32n * 0n) + (4n << 32n * 1n) + (6n << 32n * 2n)\n// 0x000000060000000400000002\n\n\nSee LimitOrderBuilder.joinStaticCalls() and LimitOrderBuilder.packInteractions() utils for help.\n\nOrder.interaction is now Order.postInteraction, as long as Order.preInteraction was added.\nNew arguments for fillOrder and fillOrderToWithPermit methods\nfunction fillOrderToWithPermit(\n    OrderLib.Order calldata order,\n    bytes calldata signature,\n+   bytes calldata interaction,\n    uint256 makingAmount,\n    uint256 takingAmount,\n-   uint256 thresholdAmount,\n+   uint256 skipPermitAndThresholdAmount,\n    address target,\n    bytes calldata permit\n)\n\ninteraction is pre-interaction in fact.\nskipPermit is just 255'th byte of skipPermitAndThresholdAmount, when rest of bytes is thresholdAmount\n\nSee fillLimitOrder(), fillOrderToWithPermit() and packSkipPermitAndThresholdAmount() utils methods and helpers.\n\nMethods eq, lt, gt, nonceEquals no more have address arguments. Use arbitraryStaticCall instead in case if you need read value from different smartcontract.\nlimit-order-protocol-utils library changes:​\nNow contract is pubshed to npm as @1inch/limit-order-protocol-utils\nThe LimitOrderProtocolFacade​\nnew chainId argument of LimitOrderProtocolFacade\nimport import { ChainId } from '@1inch/limit-order-protocol-utils/model/limit-order-protocol.model';\nnew LimitOrderProtocolFacade(\n    public readonly contractAddress: string,\n+   private readonly chainId: ChainId | number,\n    public readonly providerConnector: ProviderConnector,\n)\n\n\nLimitOrderProtocolFacade.fillLimitOrder and fillOrderToWithPermit have more abilities now:\n\nfillOrderToWithPermit({\n    order,\n    signature,\n\n-   makerAmount,\n+   makingAmount,\n\n-   takerAmount,\n+   takingAmount,\n\n    thresholdAmount,\n    targetAddress,\n    permit,\n\n+   interaction = ZX,\n+   skipPermit = false,\n})\n\ninteraction is pre-interaction in fact.\nskipPermit wether to skip maker's permit evaluation if it was evaluated before. Useful if multiple orders was created with same nonce. Tip: you can just check if allowance exsists and then set it to true.\n\nsimulateCalls(addresses[], calldatas[]): Promise<boolean> no more avaible.\n\nsimulate(address, calldata): Promise<{ success, rawResult }> was introduced insted, so you don't need catch block anymore.\n\nThe LimitOrderBuilder​\n\nLimitOrderBuilder.buildLimitOrder have more abilities now:\n\nbuildLimitOrder({\n    makerAssetAddress,\n    takerAssetAddress,\n    makerAddress,\n    receiver = ZERO_ADDRESS,\n-   takerAddress = ZERO_ADDRESS,\n+   allowedSender = ZERO_ADDRESS,\n\n-   makerAmount,\n+   makingAmount,\n\n-   takerAmount,\n+   takingAmount,\n\n    predicate = ZX,\n    permit = ZX,\n\n+   getMakingAmount,\n+   getTakingAmount,\n\n-   interaction = ZX,\n+   postInteraction = ZX,\n\n+   preInteraction = ZX,\n+   salt = this.generateSalt(),\n}: LimitOrderData)\n\nLimitOrderPredicateBuilder.timestampBelowAndNonceEquals was added to reduce gas.\n-   const predicate = and(\n-       nonceEquals(\n-           walletAddress,\n-           currentNonce,\n-       ),\n-       timestampBelow(timestamp),\n-   );\n\n+   const predicate = timestampBelowAndNonceEquals(\n+       timestamp,\n+       currentNonce,\n+       walletAddress,\n+   );\n\nThe LimitOrderPredicateBuilder​\n\nLimitOrderPredicateBuilder.arbitraryStaticCall was added to get values from other smartcontract.\n\nLimitOrderPredicateBuilder members eq, lt, gt, nonceEquals no more have address arguments. Use arbitraryStaticCall instead in case if you need read value from different smartcontract. Eg:\n\neq(\n    nonce,\n    arbitraryStaticCall(SIDE_NONCE_MANAGER_ADDRESS, callData),\n)\n\nThe SeriesNonceManagerFacade​\nWas added to help you manage different groups of \"cancel all\" nonces\nEdit this page\nPrevious\nCanceling a limit order\nNext\n1inch limit order protocol\nLimit Order Protocol itself changes\nlimit-order-protocol-utils library changes:\nThe LimitOrderProtocolFacade\nThe LimitOrderBuilder\nThe LimitOrderPredicateBuilder\nThe SeriesNonceManagerFacade"
  },
  {
    "title": "Order creation examples | 1inch Network",
    "url": "https://docs.1inch.io/docs/limit-order-protocol/examples/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nIntroduction\nLimit vs. RFQ Orders\nOrder creation examples\nJS Utils\nBreaking changes in V3\nSmart contracts\nLiquidity Source and API\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nLimit order protocolOrder creation examples\nOrder creation examples\nThrough @1inch/limit-order-protocol-utils​\n\nThis is the recomended option!\n\nThere is JavaScript and Typescript compatible library that solves everything for you, we taking care on it to make everything up to date and make you migration over Limit Order Protocol Versions as smooth as possible.\n\nSee docs on order creation\nSee library docs\n\n\n\n\nPython Example for 1inch Limit Order v3​\n\nTo place a limit order in python requires more work since there's no library\n\nIn this example the predicate only uses the timestamp to determine when the order should expire but there are many more functions that can be used for the predicate. See the limit order protocol utils github for more information.\n\nfrom eth_account.messages import encode_structured_data\nfrom web3 import Web3\nimport requests\nimport time\nw3 = Web3(Web3.HTTPProvider(\"https://cloudflare-eth.com\"))  # you can customize the RPC\nwallet_key = \"...\" # Your wallet private key without the leading 0x\nwallet_address = \"...\" # Your wallet address\nlimit_order_contract = \"0x1111111254EEB25477B68fb85Ed929f73A960582\" # the limit order contract (now the same as the 1inch v5 router)\nchain_id = 1 # the chain id of the network you are using ##didn't exist in the previoius version\nETHERSCAN_API_KEY = \"yourapikeytoken\" # Etherscan API key, this may not be required or should be changed if the ABIs are changed to literals or a different blockchain API is used like api.bscscan.com or api.polygonscan.com\n\n#create the limit order contract instance\nlimit_order_contract_abi_response = requests.get(f\"https://api.etherscan.io/api?module=contract&action=getabi&address={limit_order_contract}&apikey={ETHERSCAN_API_KEY}\")\nlimit_order_contract_abi = limit_order_contract_abi_response.json()[\"result\"]\nlimit_order_contract_instance = w3.eth.contract(address=limit_order_contract, abi=limit_order_contract_abi)\n\n# wait 5 seconds to avoid rate limiting\ntime.sleep(5)\n\n# get the token addresses for the tokens you want to trade\nerc20_abi_response = requests.get(f\"https://api.etherscan.io/api?module=contract&action=getabi&address=0x6b175474e89094c44da98b954eedeac495271d0f&apikey={ETHERSCAN_API_KEY}\")\nerc20_abi = erc20_abi_response.json()[\"result\"]\n\n#here is were we define parameters for the limit order\nmakerAddress = Web3.toChecksumAddress(wallet_address) # the address of the wallet that will be the maker of the order\ntakerAddress = Web3.toChecksumAddress(\"0x0000000000000000000000000000000000000000\") # the address of the taker, if it's address(0) then it's a public order\nmakerAsset = Web3.toChecksumAddress(\"0x6b175474e89094c44da98b954eedeac495271d0f\") # the address of the token you want to sell\ntakerAsset = Web3.toChecksumAddress(\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\") # the address of the token you want to buy\nmakerAmount = 1000 # the amount of the token you want to sell in wei\ntakerAmount = 1000000000000000000 # the amount of the token you want to buy in wei\n\nmakerAssetContract = w3.eth.contract(address=makerAsset, abi=erc20_abi)\ntakerAssetContract = w3.eth.contract(address=takerAsset, abi=erc20_abi)\n\n# other order parameters\nmakerAssetData = '0x'\ntakerAssetData = '0x'\ngetMakingAmount = '0x'\ngetTakingAmount = '0x'\nexpiration = 5444440000 # some time in the future\nnonce = 0 # the nonce of the order, used to be able to cancel all orders that have the same nonce by increasing the addresses' nonce\nseriesNonceManagerContractAddress = w3.toChecksumAddress('0x303389f541ff2d620e42832f180a08e767b28e10') # https://github.com/1inch/limit-order-protocol-utils/blob/fdbb559509eeb6e22e2697cccb22887d69617652/src/series-nonce-manager.const.ts\nseriesNonceManagerABI_response = requests.get(f\"https://api.etherscan.io/api?module=contract&action=getabi&address={seriesNonceManagerContractAddress}&apikey={ETHERSCAN_API_KEY}\")\nseriesNonceManagerABI = [{\"inputs\":[],\"name\":\"AdvanceNonceFailed\",\"type\":\"error\"},{\"anonymous\":False,\"inputs\":[{\"indexed\":True,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":False,\"internalType\":\"uint256\",\"name\":\"series\",\"type\":\"uint256\"},{\"indexed\":False,\"internalType\":\"uint256\",\"name\":\"newNonce\",\"type\":\"uint256\"}],\"name\":\"NonceIncreased\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"series\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"advanceNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"series\",\"type\":\"uint8\"}],\"name\":\"increaseNonce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"series\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"makerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerNonce\",\"type\":\"uint256\"}],\"name\":\"nonceEquals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"timestampBelow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeNonceSeriesAccount\",\"type\":\"uint256\"}],\"name\":\"timestampBelowAndNonceEquals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]\nseriesNonceManagerInstance = w3.eth.contract(address=seriesNonceManagerContractAddress, abi=seriesNonceManagerABI)\n\n\nOne of the breaking changes with v3 was the addition of the offsets parameter and the packing of the interactions\n\n# this data will be all packed into the Interactions parameter\nseries = 0 # 0 is limit order 1 is p2p order\nnonceManagerCalldata = seriesNonceManagerInstance.encodeABI(fn_name=\"timestampBelow\", args=[expiration])\npredicate = limit_order_contract_instance.encodeABI(fn_name=\"arbitraryStaticCall\", args=[seriesNonceManagerContractAddress, nonceManagerCalldata] )\npermit = '0x' # this would be used to add an EIP 712 permit to the order\npreInteraction = '0x' # this would be used to add a pre-interaction to the order\npostInteraction = '0x' # this would be used to add a post-interaction to the order, for example unwrapping wETH to ETH\n\nall_interactions = [makerAssetData, takerAssetData, getMakingAmount, getTakingAmount, predicate, permit, preInteraction, postInteraction]\n\n# this function will calculate the offsets for the interactions\ndef getOffsets(interactions):\n    lenghtMap = []\n    for interaction in interactions:\n        if interaction[0:2] == \"0x\":\n            lenghtMap.append(int(len(interaction)/2 - 1))\n        else:\n            lenghtMap.append(int(len(interaction)/2))\n    cumulativeSum = 0\n    bytesAccumularot = 0\n    index = 0\n    UINT32_BITS = 32\n    # print(lenghtMap)\n    for lenght in lenghtMap:\n        cumulativeSum += lenght\n        # bytesAccumularot + (BigInt(offset) << ((exports.UINT32_BITS * BigInt(index))));\n        # print(str(bytesAccumularot) + \" + (\" + str(cumulativeSum) + \" << (\" + str(UINT32_BITS) + \" * \" + str(index) + \"))\")\n        bytesAccumularot += cumulativeSum << (UINT32_BITS * index)\n        index += 1\n    offsets = bytesAccumularot #hex(bytesAccumularot)\n    return offsets\n\noffsets = getOffsets(all_interactions)\n\ndef trim0x(hexString):\n    if hexString[0:2] == '0x':\n        return hexString[2:]\n    return hexString\n\ninteractions = \"0x\"\nfor interaction in all_interactions:\n    interactions = interactions + trim0x(interaction)\n\n\na limit order can't be signed properly if all the types are strings here we define what each field is and the type it should be\n\n\norder_data = {\n    \"salt\": 0,\n    \"makerAsset\": makerAsset,\n    \"takerAsset\": takerAsset,\n    \"maker\": makerAddress,\n    \"receiver\": takerAddress,\n    \"allowedSender\": \"0x0000000000000000000000000000000000000000\",\n    \"makingAmount\": makingAmount,\n    \"takingAmount\": takingAmount,\n    \"offsets\": offsets,\n    \"interactions\": interactions\n}\n\norder_types = [\n    {\"name\": \"salt\", \"type\": \"uint256\"},\n    {\"name\": \"makerAsset\", \"type\": \"address\"},\n    {\"name\": \"takerAsset\", \"type\": \"address\"},\n    {\"name\": \"maker\", \"type\": \"address\"},\n    {\"name\": \"receiver\", \"type\": \"address\"},\n    {\"name\": \"allowedSender\", \"type\": \"address\"},\n    {\"name\": \"makingAmount\", \"type\": \"uint256\"},\n    {\"name\": \"takingAmount\", \"type\": \"uint256\"},\n    {\"name\": \"offsets\", \"type\": \"uint256\"},\n    {\"name\": \"interactions\", \"type\": \"bytes\"},\n]\n\n# this function will fix the order_data to be a typed object instead of only strings\ndef fix_data_types(data, types):\n    \"\"\"\n    Order data values are all strings as this is what the API expects. This function fixes their types for\n    encoding purposes.\n    \"\"\"\n    fixed_data = {}\n    for dictionary in types:\n        if \"bytes\" in dictionary[\"type\"]:\n            fixed_data[dictionary[\"name\"]] = (Web3.toBytes(hexstr=data[dictionary[\"name\"]]))\n        elif \"int\" in dictionary[\"type\"]:\n            fixed_data[dictionary[\"name\"]] = int(data[dictionary[\"name\"]])\n        else: # address\n            fixed_data[dictionary[\"name\"]] = data[dictionary[\"name\"]]\n    return fixed_data\n\n# this is a typed data that the private key will be signing, it conforms to the EIP 712 standard\neip712_data = {\n    \"primaryType\": \"Order\",\n    \"types\": {\n        \"EIP712Domain\": [\n            {\"name\": \"name\", \"type\": \"string\"},\n            {\"name\": \"version\", \"type\": \"string\"},\n            {\"name\": \"chainId\", \"type\": \"uint256\"},\n            {\"name\": \"verifyingContract\", \"type\": \"address\"},\n        ],\n        \"Order\": order_types\n    },\n    \"domain\": {\n        \"name\": \"1inch Aggregation Router\",\n        \"version\": \"5\",\n        \"chainId\": chain_id,\n        \"verifyingContract\": \"0x1111111254eeb25477b68fb85ed929f73a960582\",\n    },\n    \"message\": fix_data_types(order_data, order_types),\n}\n\n\nFinally the private key will be used to sign the encoded data and broadcast to the API\n\nIf you are having problems signing please run the following commands: pip install web3 --upgrade; pip install eth-account==0.6.1\n\nencoded_message = encode_structured_data(eip712_data)\nsigned_message = w3.eth.account.sign_message(encoded_message, wallet_key)\n# this is the limit order that will be broadcast to the limit order API\nlimit_order = {\n    \"orderHash\": signed_message.messageHash.hex(),\n    \"signature\": signed_message.signature.hex(),\n    \"data\": order_data,\n}\n\nlimit_order_url = \"https://limit-orders.1inch.io/v3.0/\"+ str(chain_id) +\"/limit-order\" # make sure to change the chain_id if you are not using ETH mainnet\nresponse = requests.post(url=limit_order_url,headers={\"accept\": \"application/json, text/plain, */*\", \"content-type\": \"application/json\"}, json=limit_order)\n# print the full response\nprint(response.text)\n\nEdit this page\nPrevious\nLimit vs. RFQ Orders\nNext\nAbout\nThrough @1inch/limit-order-protocol-utils\nPython Example for 1inch Limit Order v3"
  },
  {
    "title": "Limit vs. RFQ Orders | 1inch Network",
    "url": "https://docs.1inch.io/docs/limit-order-protocol/types/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nIntroduction\nLimit vs. RFQ Orders\nOrder creation examples\nJS Utils\nBreaking changes in V3\nSmart contracts\nLiquidity Source and API\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nLimit order protocolLimit vs. RFQ Orders\nLimit vs. RFQ Orders\n\nThe Limit Order Protocol provides users with options to place both Limit orders and Request For Quote (RFQ) orders. Select the appropriate order type based on your specific needs.\n\nComparison Table​\nCriteria\tLimit Order\tRFQ Order\nSuitable for\tTraders\tMarket Makers\nFlexibility of features\tHigh; includes Order predicates, callbacks. Details\tLimited due to gas optimization; Supports expiration time, partial fills (once), and cancellation by ID. Details\nExecution\tUses Pathfinder algorithm for liquidity.\tExposed via API; requires quote requests; optimized for one-time fills.\nKey Characteristics\tOffers at a fixed price (0 slippage); various trading features/tools can be built.\tMirrors \"request for quotation\"; designed for market makers and gas efficiency.\n\nBoth order types support ERC20, ERC721, and ERC1155 tokens. Other token standards might be supported in the future.\n\nMore resources​\n\nFurther Reading: Explore Limit Order and RFQ Order here.\n\nTry directly at 1inch dApp.\nView the Smart Contracts repository.\nDevelopers, check out the Utils library repository.\nEdit this page\nPrevious\nIntroduction\nNext\nOrder creation examples\nComparison Table\nMore resources"
  },
  {
    "title": "Quick start | 1inch Network",
    "url": "https://docs.1inch.io/docs/aggregation-protocol/guide/quick-start/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nIntroduction\nGuide\nQuick start\nAPI\nSmart contracts\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nAggregation ProtocolGuideQuick start\nQuick start\n\nIn this guide, we will provide an example token swap of 0.1 1INCH for DAI at the best possible rate on the market.\n\nThis process includes:\n\nChecking allowances​\nCreating the allowance/approval transaction​\nMaking a swap​\nTIP\n\nThis example uses Binance Chain network; however, it can be replicated on any network supported by 1inch Aggregation Protocol.\n\nChecking allowances​\nStep 1: Set Up Your Environment​\n\nFirst, import the necessary Node.js libraries and set up your environment variables.\n\nconst Web3 = require('web3'); // Import the Web3 library for interacting with Ethereum\nconst fetch = require('node-fetch'); // Import the fetch library for making HTTP requests\nconst yesno = require('yesno'); // Import the yesno library for prompting user input\n\nconst chainId = 56; // The chain ID for the Binance Smart Chain (BSC)\nconst web3RpcUrl = 'https://bsc-dataseed.binance.org'; // The URL for the BSC node you want to connect to\nconst walletAddress = '0x...xxx'; // Set your wallet address (replace '0x...xxx' with your actual wallet address)\nconst privateKey = '0x...xxx'; // Set the private key of your wallet (replace '0x...xxx' with your actual private key). NEVER SHARE THIS WITH ANYONE!\n\nStep 2: Define Your Swap Parameters​\n\nNext, define the parameters for the swap you want to perform.\n\nconst swapParams = {\n    fromTokenAddress: '0x111111111117dc0aa78b770fa6a738034120c302', // The address of the token you want to swap from (1INCH)\n    toTokenAddress: '0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3', // The address of the token you want to swap to (DAI)\n    amount: '100000000000000000', // The amount of the fromToken you want to swap (in wei)\n    fromAddress: 'YOUR_WALLET_ADDRESS', // Your wallet address from which the swap will be initiated\n    slippage: 1, // The maximum acceptable slippage percentage for the swap (e.g., 1 for 1%)\n    disableEstimate: false, // Whether to disable estimation of swap details (set to true to disable)\n    allowPartialFill: false, // Whether to allow partial filling of the swap order (set to true to allow)\n};\n\nINFO\nFor complete swap parameter descriptions, see this page.\namount: '100000000000000000': This value is used because 1INCH token has 18 decimals as part of the ERC-20 token standard. Learn more.\nStep 3: Define API URLs and Initialize Web3 Libraries​\n\nNow, define the API URLs and initialize Web3. Web3 is a collection of libraries which allow you to interact with a local or remote Ethereum node, using HTTP, IPC, or WebSocket.\n\nconst broadcastApiUrl = 'https://tx-gateway.1inch.io/v1.1/' + chainId + '/broadcast';\nconst apiBaseUrl = 'https://api.1inch.io/v5.0/' + chainId;\nconst web3 = new Web3(web3RpcUrl);\n\nStep 4: Define Helper Functions​\n\nDefine a series of helper functions that will be used to interact with the 1inch API.\n\n// Construct full API request URL\nfunction apiRequestUrl(methodName, queryParams) {\n    return apiBaseUrl + methodName + '?' + (new URLSearchParams(queryParams)).toString();\n}\n\nfunction checkAllowance(tokenAddress, walletAddress) {\n    return fetch(apiRequestUrl('/approve/allowance', {tokenAddress, walletAddress}))\n        .then(res => res.json())\n        .then(res => res.allowance);\n}\n\nStep 5: Check Token Allowance​\n\nUse the checkAllowance function to check the current allowance of the token.\n\nconst allowance = await checkAllowance(swapParams.fromTokenAddress, walletAddress);\nconsole.log('Allowance: ', allowance);\n\n\nAt this point, you'll have set up your environment, defined your swap parameters, defined your API endpoints, and checked the allowance for the token you are selling.\n\nNOTE\n\nIf you haven't previously approved or swapped this asset using 1inch Aggregation Protocol, then > Allowance: 0 will be displayed in the console. This means that the 1inch router does not have access to swap this token within your wallet.\n\nCreating the token allowance (approval) transaction​\n\nIn order for the 1inch aggregation protocol to access tokens in your wallet, you must create an approval transaction. This specifies that the 1inch router is allowed to swap a specific amount of the token chosen.\n\nCAUTION\n\nApproval transactions require payment of a blockchain gas fee! This amount is deducted in the form of native tokens from your wallet.\n\nStep 1:​\n\nSimilar to the Allowance Check, you'll first need to set up your environment, define swap parameters and API endpoints, and initialize Web3 libraries.\n\nconst Web3 = require('web3');\nconst fetch = require('node-fetch');\nconst yesno = require('yesno');\n\nconst chainId = 56;\nconst web3RpcUrl = 'https://bsc-dataseed.binance.org';\nconst walletAddress = '0x...xxx'; // Set your wallet address\nconst privateKey = '0x...xxx'; // Set private key of your wallet. Be careful! NEVER share this key with anyone!\n\nconst swapParams = {\n    fromTokenAddress: '0x111111111117dc0aa78b770fa6a738034120c302', // 1INCH\n    toTokenAddress: '0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3', // DAI\n    amount: '100000000000000000', //18 decimals (in gwei)\n    fromAddress: walletAddress,\n    slippage: 1,\n    disableEstimate: false,\n    allowPartialFill: false,\n};\n\n// API endpoints\nconst broadcastApiUrl = 'https://tx-gateway.1inch.io/v1.1/' + chainId + '/broadcast';\nconst apiBaseUrl = 'https://api.1inch.io/v5.0/' + chainId;\nconst web3 = new Web3(web3RpcUrl);\n\nStep 2: Implement Helper Functions​\n\nImplement helper functions to interact with the 1inch API, including constructing the API request URL, broadcasting raw transactions, signing and sending transactions, and preparing approval transactions considering the gas limit.\n\n// Construct full API request URL\nfunction apiRequestUrl(methodName, queryParams) {\n    return apiBaseUrl + methodName + '?' + (new URLSearchParams(queryParams)).toString();\n}\n\n// Post raw transaction to the API and return transaction hash\nasync function broadCastRawTransaction(rawTransaction) {\n    return fetch(broadcastApiUrl, {\n        method: 'post',\n        body: JSON.stringify({ rawTransaction }),\n        headers: { 'Content-Type': 'application/json' }\n    })\n        .then(res => res.json())\n        .then(res => {\n            return res.transactionHash;\n        });\n}\n\n// Sign and post a transaction, return its hash\nasync function signAndSendTransaction(transaction) {\n    const { rawTransaction } = await web3.eth.accounts.signTransaction(transaction, privateKey);\n\n    return await broadCastRawTransaction(rawTransaction);\n}\n\n// Prepare approval transaction, considering gas limit\nasync function buildTxForApproveTradeWithRouter(tokenAddress, amount) {\n    const url = apiRequestUrl(\n        '/approve/transaction',\n        amount ? { tokenAddress, amount } : { tokenAddress }\n    );\n\n    const transaction = await fetch(url).then(res => res.json());\n\n    const gasLimit = await web3.eth.estimateGas({\n        ...transaction,\n        from: walletAddress\n    });\n\n    return {\n        ...transaction,\n        gas: gasLimit\n    };\n}\n\nStep 3: Build the Body of the Transaction​\n\nPrepare the transaction data for approval using the buildTxForApproveTradeWithRouter function and store it in transactionForSign.\n\nconst transactionForSign = await buildTxForApproveTradeWithRouter(swapParams.fromTokenAddress);\nconsole.log('Transaction for approve: ', transactionForSign);\n\nStep 4: Confirm and Send the Transaction​\n\nPrompt the user to confirm the transaction using the yesno library. If confirmed, sign and send the transaction. Otherwise, exit without signing.\n\nconst ok = await yesno({\n    question: 'Do you want to send a transaction to approve trade with 1inch router?'\n});\n\nif (!ok) {\n    return false;\n}\n\nconst approveTxHash = await signAndSendTransaction(transactionForSign);\nconsole.log('Approve tx hash: ', approveTxHash);\n\n\nAfter running this code in the console, you should see something like this:\n\n> Approve tx hash: 0xb87c133e203fe66b487e27ab0afde71842dc34ab97aca60c147c7662505312a6\n\nWith the transaction hash, you can monitor its execution using the blockchain explorer.\n\nFor the Binance Chain, you can use bscscan.com: https://bscscan.com/tx/0xb87c133e203fe66b487e27ab0afde71842dc34ab97aca60c147c7662505312a6\n\nThat's it! At this point, you have checked for token allowances and sent a transaction granting the 1inch router access to your tokens. Next, we will make the swap!\n\n\n\nMaking the Swap​\nCAUTION\n\nBefore proceeding, please confirm that your approval transaction has a status of Success!\n\nStep 1: Set Up Environment and Define Swap Parameters​\n// Set up environment and import necessary libraries\nconst Web3 = require('web3');\nconst fetch = require('node-fetch');\nconst yesno = require('yesno');\n\n// Define the chain ID and Web3 RPC URL\nconst chainId = 56;\nconst web3RpcUrl = 'https://bsc-dataseed.binance.org';\n\n// Set your wallet address and private key\nconst walletAddress = '0x...xxx';\nconst privateKey = '0x...xxx';\n\n// Define the swap parameters\nconst swapParams = {\n    fromTokenAddress: '0x111111111117dc0aa78b770fa6a738034120c302', // 1INCH\n    toTokenAddress: '0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3', // DAI\n    amount: '100000000000000000',\n    fromAddress: walletAddress,\n    slippage: 1,\n    disableEstimate: false,\n    allowPartialFill: false,\n};\n\nStep 2: Implement Helper Functions​\n// Define the API endpoints for broadcasting and interacting with 1inch\nconst broadcastApiUrl = 'https://tx-gateway.1inch.io/v1.1/' + chainId + '/broadcast';\nconst apiBaseUrl = 'https://api.1inch.io/v5.0/' + chainId;\n\n// Create a new instance of Web3 using the provided RPC URL\nconst web3 = new Web3(web3RpcUrl);\n\n// Construct the full API request URL based on the method and query parameters\nfunction apiRequestUrl(methodName, queryParams) {\n    return apiBaseUrl + methodName + '?' + (new URLSearchParams(queryParams)).toString();\n}\n\n// Post a raw transaction to the 1inch API and return the transaction hash\nasync function broadCastRawTransaction(rawTransaction) {\n    return fetch(broadcastApiUrl, {\n        method: 'post',\n        body: JSON.stringify({ rawTransaction }),\n        headers: { 'Content-Type': 'application/json' }\n    })\n        .then(res => res.json())\n        .then(res => {\n            return res.transactionHash;\n        });\n}\n\n// Sign and send a transaction using the provided private key\nasync function signAndSendTransaction(transaction) {\n    const { rawTransaction } = await web3.eth.accounts.signTransaction(transaction, privateKey);\n\n    return await broadCastRawTransaction(rawTransaction);\n}\n\nStep 3: Build the Body of the Transaction​\n// Prepare the transaction data for the swap by making an API request\nasync function buildTxForSwap(swapParams) {\n    const url = apiRequestUrl('/swap', swapParams);\n\n    // Fetch the swap transaction details from the API\n    return fetch(url)\n        .then(res => res.json())\n        .then(res => res.tx);\n}\n\n// First, let's build the body of the transaction\nconst swapTransaction = await buildTxForSwap(swapParams);\nconsole.log('Transaction for swap: ', swapTransaction);\n\nStep 4: Confirm and Send the Transaction​\n// Prompt the user to confirm the transaction before signing and sending it\nconst ok = await yesno({\n    question: 'Do you want to send a transaction to exchange with 1inch router?'\n});\n\n// Confirm that all parameters are specified correctly before signing the transaction\nif (!ok) {\n    return false;\n}\n\n// Sign and send the swap transaction, and retrieve the transaction hash\nconst swapTxHash = await signAndSendTransaction(swapTransaction);\nconsole.log('Transaction Signed and Sent: ', swapTxHash);\n\n\nAfter running this code in the console, you should see something like this:\n\n> Swap tx hash: 0xe591e17cc2b33e6a244fb2a98deb83b4659f94cf867ef7730b614d1feaa7cf9d\n\nLet's check the result of the transaction on the explorer: https://bscscan.com/tx/0xe591e17cc2b33e6a244fb2a98deb83b4659f94cf867ef7730b614d1feaa7cf9d\n\nEdit this page\nPrevious\nIntroduction\nNext\nLegal\nChecking allowances\nStep 1: Set Up Your Environment\nStep 2: Define Your Swap Parameters\nStep 3: Define API URLs and Initialize Web3 Libraries\nStep 4: Define Helper Functions\nStep 5: Check Token Allowance\nCreating the token allowance (approval) transaction\nStep 1:\nStep 2: Implement Helper Functions\nStep 3: Build the Body of the Transaction\nStep 4: Confirm and Send the Transaction\nMaking the Swap\nStep 1: Set Up Environment and Define Swap Parameters\nStep 2: Implement Helper Functions\nStep 3: Build the Body of the Transaction\nStep 4: Confirm and Send the Transaction"
  },
  {
    "title": "IUniswapV3SwapCallback | 1inch Network",
    "url": "https://docs.1inch.io/docs/aggregation-protocol/smart-contract/interfaces/IUniswapV3SwapCallback/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nIntroduction\nGuide\nAPI\nSmart contracts\nAggregationRouterV5\nClipperRouter\nLimitOrderProtocolRFQ\nUnoswapRouter\nUnoswapV3Router\nhelpers\ninterfaces\nIUniswapV3SwapCallback\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nAggregation ProtocolSmart contractsinterfacesIUniswapV3SwapCallback\nIUniswapV3SwapCallback\n\nCallback for IUniswapV3PoolActions#swap\n\nAny contract that calls IUniswapV3PoolActions#swap must implement this interface\n\nFunctions​\nuniswapV3SwapCallback​\nfunction uniswapV3SwapCallback(\n  int256 amount0Delta,\n  int256 amount1Delta,\n  bytes data\n) external\n\n\nCalled to msg.sender after executing a swap via IUniswapV3Pool#swap.\n\nIn the implementation you must pay the pool tokens owed for the swap. The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory. amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n\nParameters:​\nName\tType\tDescription\namount0Delta\tint256\tThe amount of token0 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token0 to the pool.\namount1Delta\tint256\tThe amount of token1 that was sent (negative) or must be received (positive) by the pool by the end of the swap. If positive, the callback must send that amount of token1 to the pool.\ndata\tbytes\tAny data passed through by the caller via the IUniswapV3PoolActions#swap call\nEdit this page\nPrevious\nPermitable\nNext\nIntroduction\nFunctions\nuniswapV3SwapCallback"
  },
  {
    "title": "Wallet auto-connect | 1inch Network",
    "url": "https://docs.1inch.io/docs/wallet-auto-connect/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nWallet auto-connect\nWallet auto-connect\nHow to implement the wallet auto-connect​\n\nWeb3 browser in 1inch Wallet injects JavaScript code/objects when opening a webpage.\n\nSo first it is necessary to find out if the provider has been injected:\n\nexport function isOneInchWalletProviderInjected(): boolean {\n        return Boolean(ethereum?.isOneInchIOSWallet || ethereum?.isOneInchAndroidWallet);\n}\n\n\nThe next step is to retrieve the net/address, thus it would be classified as a connection.\n\n// Retrieving accounts: eth_requestAccounts returns the current one, it gives an array containing single address\nconst accounts = await ethereum.request({ method: 'eth_requestAccounts' });\n\n// returns id of the network in hex-format\nconst currentChain = await ethereum.request({ method: 'eth_chainId' });\n\nEdit this page\nPrevious\nSwitching between networks\nNext\nOverview\nHow to implement the wallet auto-connect"
  },
  {
    "title": "1inch Network Overview | 1inch Network",
    "url": "https://docs.1inch.io/docs/1inch-network-overview/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\n1inch Network Overview\n1inch Network Overview\nWhat is the 1inch Network?​\n\nThe 1inch Network (https://1inch.io/) unites decentralized protocols whose synergy enables the most lucrative, fastest, and protected operations in the DeFi space by offering access to hundreds of liquidity sources across multiple chains. The 1inch Network was launched at the ETHGlobal New York hackathon in May 2019 with the release of its Aggregation Protocol v1. Since then, 1inch Network has developed additional DeFi tools such as the Liquidity Protocol, Limit Order Protocol, P2P transactions, and 1inch Mobile Wallet.\n\n1inch dApp – a web-based application that is connected to all supported blockchains via smart contracts. The dApp offers access to deep aggregated liquidity and competitive token swap rates on various DEXes, with unique features, including partial fill and the ability to find the best swap paths across multiple liquidity sources.\n\n1inch Aggregation Protocol – the 1inch API v5, Pathfinder, is a cutting-edge discovery and routing algorithm, which offers asset exchanges at the best rates on the market. Pathfinder finds the most efficient paths for a token swap, able to split between different protocols and even different market depths within one protocol in the shortest possible time.\n\n1inch Liquidity Protocol – 1inch Liquidity protocol (previously called Mooniswap) is an AMM that aims to offer capital-efficient liquidity positions while protecting users from front-running.\n\n1inch Limit Order Protocol – 1inch Limit Order Protocol is a set of smart contracts that allows users to place limit orders, and RFQ Orders, which later can be filled on-chain. Both types of orders are a data structure created off-chain and signed according to EIP-712. Key features of the protocol are extreme flexibility and high gas efficiency. Thanks to the gasless limit order feature, an entry threshold for new users of 1inch protocols became significantly lower.\n\nP2P Transactions – 1inch Peer-to-Peer allows two users to make an over-the-counter style trade of any ERC20 token.\n\n1inch Mobile Wallet – The 1inch Wallet is a non-custodial crypto wallet with the best swap rates and the swiftest web3 browsing experience. Available both on iOS and Android.\n\nSupported Networks – 1inch protocols are deployed on the following Ethereum Virtual Machine (EVM) networks: Ethereum, BNB Chain, Polygon, Arbitrum, Optimism, Gnosis Chain, Avalanche, Klaytn, Aurora, zkSync Era and Fantom.\n\n1inch Foundation, 1inch core contributors, 1inch DAO​\n\nThe 1inch Network is composed of three distinct groups of stakeholders: the 1inch Foundation, the 1inch core contributors, and the 1inch DAO. All stakeholders are working towards the common goal of growing the 1inch Network in a decentralized manner.\n\nThough they share a common goal, each group operates totally independently. For example, the DAO can signal to the Foundation that they want to see certain changes. However, if the Foundation cannot implement these changes for whatever reason, the DAO will need to fund the development and implementation of these changes themselves.\n\n1inch Foundation​\n\nThe 1inch Foundation is an independent non-profit organization. Its mission is to foster the 1inch Network’s growth and support initiatives that benefit the 1inch Network's community. The 1inch Foundation issued the 1INCH token, but the 1inch DAO has control over the token smart contract in the 1inch Network. As part of its mission, the 1inch Foundation is focused on, among others, the following areas:\n\nOwnership and control of the 1inch.io domain name, and 1inch front-end;\n\nOwnership and control of the 1inch: Crypto DeFi Wallet;\n\nMaximizing the 1inch Network’s decentralization;\n\nGrowing the number of stakeholders and governance participants;\n\nIncentivizing developers to build on top of 1inch Network’s protocols;\n\nGrant issuance;\n\nFarming programs and gas refunds;\n\nNetwork research and analytics;\n\nIntegrations that increase usage of the 1inch Network;\n\nOrganizing events; and\n\nEducation.\n\nTo finance these goals, the 1inch Foundation maintains control of its own funds (separate from the DAO treasury).\n\n1inch core contributors​\n\nThe 1inch core contributors are a decentralized group of 1inch Network technical contributors dedicated to building out the 1inch Network. Among the technical contributors, the largest contributor is 1inch Labs. 1inch Labs concentrates on, among others, the following areas:\n\nProviding general software development services for the 1inch Network and others;\n\nMaintaining the 1inch Pathfinder algorithm and API; and\n\nServing as a SaaS (software as a service) provider of its Pathfinder algorithm for certain enterprise clients.\n\n1inch DAO​\n\nThe 1inch DAO is the decentralized autonomous organization that governs the 1inch Network through a set of onchain smart contracts. Voting on the DAO is through the 1INCH token, a governance token, that was initially distributed to the community of 1inch Network users in late 2020. The 1inch DAO has control, among others, over the following:\n\nLiquidity Protocol Instant Governance;\n\nAggregation Protocol Instant Governance;\n\n1INCH token;\n\n1inch Network revenue stream; and\n\n1inch Network DAO Treasury.\n\nIn addition to the on-chain assets currently controlled by the DAO, it also has the ability to fund the development of modules/contracts and deploy them (e.g., alternative front-ends, new network deployments, new API integrations, integrations, new smart contract deployments, etc.).\n\nSince the 1inch DAO is structured in a trust-minimized fashion, all actions taken by the DAO require a vote from the 1INCH token holders.\n\nEdit this page\nNext\nIntroduction\nWhat is the 1inch Network?\n1inch Foundation, 1inch core contributors, 1inch DAO\n1inch Foundation\n1inch core contributors\n1inch DAO"
  },
  {
    "title": "Introduction | 1inch Network",
    "url": "https://docs.1inch.io/docs/educational-resources/introduction",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nIntroduction\nBeginner\nIntermediate\nAdvanced\nEducational ResourcesIntroduction\nIntroduction\nEducational Resources​\n\nWelcome to a comprehensive collection of articles designed to help you navigate the 1inch Network ecosystem. Organized into three levels - beginner, intermediate, and advanced - catering to varying levels of expertise.\n\nBeginner​\n\nIf you're new to 1inch, start here. This will provide a solid foundation in understanding key concepts, terms, and basic actions within the 1inch Network ecosystem. You'll learn about staking, delegating, and protecting yourself from market dynamics like price impact and slippage.\n\nIntermediate​\n\nFor those who have some experience and are looking to deepen their understanding, our intermediate articles offer guidance on using the 1inch dApp and related protocols. You'll find resources on troubleshooting the 1inch API, as well as learning how to interpret 1inch swap on block explorers.\n\nAdvanced​\n\nDive into more complex topics and explore advanced strategies. These resources are tailored for developers who have a strong grasp of DeFi concepts and are ready to take their knowledge to the next level. Learn about reading transaction input data, understanding MEV, and much more.\n\nEdit this page\nPrevious\nGlossary\nNext\n1INCH Token\nEducational Resources\nBeginner\nIntermediate\nAdvanced"
  },
  {
    "title": "Contract interaction | 1inch Network",
    "url": "https://docs.1inch.io/docs/fusion-swap/becoming-a-resolver/contracts-interaction/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nIntroduction\nBecoming a Resolver\nHow to become a resolver\nResolver verification\nResolver’s setup script example\nContract interaction\nFusion SDK\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nFusion swapBecoming a ResolverContract interaction\nContract interaction\nDeployed contracts​\nName\tContract\tAddress\nStaking v2\tst1inch\t0x9A0C8Ff858d273f57072D714bca7411D717501D7\nStaking farm\tStakingFarmingPod\t0x1A87c0F9CCA2f0926A155640e8958a8A6B0260bE\nSettlement\tSettlement\t0xA88800CD213dA5Ae406ce248380802BD53b47647\nDelegation pod\tPowerPod\t0xAccfAc2339e16DC80c50d2fa81b5c2B049B4f947\nResolver information\tResolverMetadata\t0xBF4543819ECede56220bcB1e8C1BBa9Ef290a58a\nWhitelist\tWhitelistRegistry\t0xcb8308fcB7BC2f84ed1bEa2C016991D34de5cc77\nWhitelist info\tWhitelistHelper\t0xF779bdde38C39138Dcaf1514B8a6b8a6C165642D\nStake 1inch​\nRepository\tlimit-order-settlement\nContract\tst1inch.sol\nContract address\t0x9A0C8Ff858d273f57072D714bca7411D717501D7\nMethods\tStaking\n\n• deposit(uint256 amount, uint256 duration) • depositWithPermit(uint256 amount, uint256 duration, bytes calldata permit) • depositFor(address account, uint256 amount, uint256 duration) • depositForWithPermit(address account, uint256 amount, uint256 duration, bytes calldata permit) | | Description | Stakes 1inch to get staking power according to the lock time |\n\n//*Deposits 100 1inch with 1 day lock*\nawait st1inch.deposit(ether('100'), time.duration.days('1'));\n\n2. Register as a Resolver​\n2.1 Register delegation pod​\nRepository\tlimit-order-settlement\nContract\tPowerPod.sol\nContract address\t0x9A0C8Ff858d273f57072D714bca7411D717501D7\nMethods\taddPod(address pod)\nDescription\tRegister pod usage for the tx sender. Needed for\n\n• Resolvers to enable resolver’s and delegated staking power usage for whitelisting • Stakers to enable unicorn power delegation |\n\n*// register `delegation` pod usage a `resolver`*\nawait st1inch.connect(resolver).addPod(delegation.address);\n\n2.2. Register delegation share token​\nRepository\tlimit-order-settlement\nContract\tPowerPod.sol\nContract address\t0xAccfAc2339e16DC80c50d2fa81b5c2B049B4f947\nMethods\tregister(string memory name, string memory symbol, uint256 maxUserFarms)\nDescription\tCreates a resolvers share token to count delegated staked power shares and accrue rewards\n*// Register resolver's token with name 'resolver token share' and symbol 'RTS'*\nawait delegation.register('resolver token share', 'RTS');\n\n2.4. Delegate resolver’s staking power to self​\nRepository\tlimit-order-settlement\nContract\tPowerPod.sol\nContract address\t0xDAf782667d98d5069eE7ba139932945C4D08fDE9\nMethods\tdelegate(address delegatee)\nDescription\tdelegate(address delegatee)\n*// Delegates all staking power to self*\nawait delegation.connect(resolver).delegate(resolver.address);\n\n2.5. Whitelist resolver​\nRepository\tlimit-order-settlement\nContract\tWhitelistRegistry.sol\nContract address\t0xcb8308fcB7BC2f84ed1bEa2C016991D34de5cc77\nMethods\tregister()\nDescription\tChecks if sender is eligible to be whitelisted and put it into the whitelist sorted by staking power descending\n*// Try to put the sender to the whitelist*\nawait whitelist.connect(resolver).register();\n\n3. FeeBank​\nRepository\tlimit-order-settlement\nContract\tFeeBank.sol\nContract address\t0xa0844e046a5B7Db55Bb8DcdFfbF0bBF9c6dc6546\nMethods\t• deposit(uint256 amount)\n\n• depositFor(address account, uint256 amount) • depositWithPermit(uint256 amount, bytes calldata permit) • depositForWithPermit | | Description | Deposits 1inch for fee deduction when filling orders |\n\n*// Deposit fees to fee bank*\nawait feeBank.connect(resolver).deposit(amount)\n\n4. Resolving​\nstruct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n        uint256 offsets;\n        // bytes makerAssetData;\n        // bytes takerAssetData;\n        // bytes getMakingAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n        // bytes getTakingAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n        // bytes predicate;       // this.staticcall(bytes) => (bool)\n        // bytes permit;          // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n        // bytes preInteraction;\n        // bytes postInteraction;\n        bytes interactions; // concat(makerAssetData, takerAssetData, getMakingAmount, getTakingAmount, predicate, permit, preIntercation, postInteraction)\n    }\n\nRepository\tlimit-order-settlement\nContract\tSettlement.sol\nContract address\t0xA88800CD213dA5Ae406ce248380802BD53b47647\nMethods\t.settleOrders(bytes calldata data)\nDescription\tSettles an order\nEdit this page\nPrevious\nResolver’s setup script example\nNext\nSDK Overview\nDeployed contracts\nStake 1inch\n2. Register as a Resolver\n2.1 Register delegation pod\n2.2. Register delegation share token\n2.4. Delegate resolver’s staking power to self\n2.5. Whitelist resolver\n3. FeeBank\n4. Resolving"
  },
  {
    "title": "Resolver’s setup script example | 1inch Network",
    "url": "https://docs.1inch.io/docs/fusion-swap/becoming-a-resolver/resolver-setup-script-example/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nIntroduction\nBecoming a Resolver\nHow to become a resolver\nResolver verification\nResolver’s setup script example\nContract interaction\nFusion SDK\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nFusion swapBecoming a ResolverResolver’s setup script example\nResolver’s setup script example\n\nThe following script executes the steps to become a resolver:\n\nApprove staking 1inch for 1inch contract.\nStake 1inch to gain unicorn power.\nAdd a delegation pod to enable power delegation.\nRegister yourself to be a resolver.\n(Optional) Change the default farm to a new farm.\nDelegate available unicorn power to yourself.\nRegister a resolver at the whitelist.\nSet up a worker to settle fusion orders.\nSetup script example​\nconst { ether, time } = require('@1inch/solidity-utils');\nconst { ethers } = require('hardhat');\n\n// Setup envirement\nconst inch = await ethers.getContractAt('IERC20', '0x111111111117dc0aa78b770fa6a738034120c302');\nconst st1inch = await ethers.getContractAt('IERC20', '0x9a0c8ff858d273f57072d714bca7411d717501d7');\nconst powerPod = await ethers.getContractAt('IERC20', '0xaccfac2339e16dc80c50d2fa81b5c2b049b4f947');\nconst whitelist = await ethers.getContractAt('WhitelistRegistry', '0xcb8308fcB7BC2f84ed1bEa2C016991D34de5cc77');\n\nconst stakeAmount = ether('1000000');\nconst lockTime = time.duration.years('2');\nconst myShareToken = {\n    name: 'MyShareTokenName',\n    symbol: 'MST',\n};\nconst worker = '...'; // Address of wallet which send transaction\nconst [resolver] = await ethers.getSigners();\n\n// Ethers setup script\n\n// approve 1inch staking\nawait (await inch.connect(resolver).approve(st1inch.address, stakeAmount));\n// stake 1inch token\nawait (await st1inch.connect(resolver).deposit(stakeAmount, lockTime)).wait();\n// add delegation pod to\n// 1. make it possible for any user to delegate staking power to\n// the resolver's account\n// 2. make it possible for a resolver to allocate its staking power for itself\nawait (await st1inch.connect(resolver).addPod(powerPod.address)).wait();\n\n// register resolver's delegation token to count stakers' shares and rewards\nawait (\n    await powerPod\n        .connect(resolver)\n        .functions['register(string,string)'](\n            myShareToken.name,\n            myShareToken.symbol,\n        )\n).wait();\n\n// Delegate staked power to self\nawait (await powerPod.connect(resolver).delegate(resolver.address)).wait();\n\n// Whitelist resolver (there should be enough unicorn power to be in top 10)\nawait (await whitelist.connect(resolver).register()).wait();\n\n// Add worker address from which order settlement will be executed\nawait (await whitelist.connect(resolver).promote(1, worker)).wait();\n\nEdit this page\nPrevious\nResolver verification\nNext\nContract interaction\nSetup script example"
  },
  {
    "title": "How to become a resolver | 1inch Network",
    "url": "https://docs.1inch.io/docs/fusion-swap/becoming-a-resolver/how-to-become-resolver/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nIntroduction\nBecoming a Resolver\nHow to become a resolver\nResolver verification\nResolver’s setup script example\nContract interaction\nFusion SDK\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nFusion swapBecoming a ResolverHow to become a resolver\nHow to become a resolver\n\nTo fill an order, a resolver must be whitelisted and have a sufficient balance to pay the order fee. Follow these steps to begin resolving:\n\nGain enough unicorn power to be listed among the top 10 registered resolvers. There are two options available to grow your unicorn power:\nStake more 1inch or lock your stake for a longer period.\nAttract more delegates through farming to delegate their unicorn power to you.\nRegister as a resolver in the whitelist and delegation, and set up a worker address.\nDeposit 1inch into the FeeBank to cover resolving fees.\nStart resolving swaps.\nStaking and delegation​\nStaking and Unicorn Power​\n\nThe top 10 whitelisted stakers are determined by their \"unicorn power.\" Stakers can lock their 1inch tokens in the staking contract to receive st1inch tokens. The lock period can be set between 1 month and 2 years. St1inch tokens grant a staker \"unicorn power.\" The longer the lock period, the more unicorn power a staker will receive. However, the increase in power is not linear:\n\nA 2-year lock will give the staker 1 \"unicorn power\" for each 1inch token locked.\nA 1.5-year lock will give the staker 0.47 \"unicorn power\" for each 1inch token locked.\nA 1-year lock will give the staker 0.22 \"unicorn power\" for each 1inch token locked.\nA 0.5-year lock will give the staker 0.1 \"unicorn power\" for each 1inch token locked.\nAn expired lock will only give the staker 0.05 \"unicorn power\" for each 1inch token locked.\nDelegation​\n\nTo help overcome the entry barrier for the whitelist, a resolver can engage 1inch stakers to delegate their \"unicorn power\" to it.\n\nWhen a staker delegates its \"unicorn power\" to a resolver, it is added to the resolver's own \"unicorn power\" and helps it enter and remain in the whitelist. Delegated \"unicorn power\" gradually decreases over time with a lock period, in the same way as a resolver's \"unicorn power\".\n\nA staker can delegate all of its power to a single resolver at any time.\n\nFarmings​\n\nTo encourage stakers to delegate their \"unicorn power,\" Fusion infrastructure creates a default farm for each resolver. When a staker delegates its \"unicorn power\" to a resolver, it automatically joins to the farm. The resolver who owns the farm may provide rewards for joined delegates, which are distributed proportionally based on their delegated \"unicorn power\" and the time spent delegating. A resolver may also redefine the farm that a delegate automatically joins after delegation.\n\nRegister as a resolver​\n\nHaving sufficient \"unicorn power\" is not enough for a Resolver. They must also be enlisted as a resolver, which involves the following actions:\n\nRead and agree to 1inch Network Fusion Swap Terms of Use for Resolvers. By following and completing the following actions and registration steps to become a Resolver, you agree that you read, understood, and consent to 1inch Network Fusion Swap Terms of Use for Resolvers.\nComplete the Resolver Verification Process. More details can be found here.\nRegister a delegation pod. A delegation pod is a smart contract that manages the accounting for delegatee and delegates unicorn power and shares. Whitelist queries the delegation pod to obtain the resulting resolver's unicorn power. After registering, a resolver should delegate its unicorn power to itself, so that it will be taken into account by the whitelist.\nRegister at whitelist If a resolver has sufficient delegated unicorn power, it can be whitelisted and given the ability to fill orders from the start of an action. Only 10 resolvers can be whitelisted. The whitelist is recalculated only when someone attempts to register. So, if the unicorn power of a whitelisted resolver drops below that of a resolver who is not whitelisted, the whitelist will change only if someone calls register on a whitelist contract.\nDefine worker address If a resolver wants to fill orders from an address other that is whitelisted, they should define a worker address for this purpose. If a resolver wants to fill orders from their own address, they should register their own address as a worker.\n\nIf a resolver is not whitelisted, it cannot fill orders.\n\nFee bank​\n\nAlthough fees are not currently being collected, it is possible that they may be collected in the future.\n\nFor each filled order, a resolver must pay a fee. This fee is automatically deducted from the resolver's account at FeeBank, which is a smart contract. If the resolver's account balance is insufficient, the order fill will be reverted. Therefore, a resolver must deposit enough 1inch tokens to fill their orders.\n\nIf a worker is designated for filling orders, a deposit should be made into this worker's account at the FeeBank.\n\nResolving​\n\nOnce all the previously described requirements have been met and steps have been completed, a resolver may begin filling orders by calling the settleOrders method of the settlement contract. If a resolver wants to fill multiple orders in one transaction, they should include the taker's interactions with chain order fill.\n\nFor more details, please refer to the limit orders documentation.\n\nEdit this page\nPrevious\nIntroduction\nNext\nResolver verification\nStaking and delegation\nStaking and Unicorn Power\nDelegation\nFarmings\nRegister as a resolver\nFee bank\nResolving"
  },
  {
    "title": "Liquidity Source and API | 1inch Network",
    "url": "https://docs.1inch.io/docs/limit-order-protocol/api/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nIntroduction\nLimit vs. RFQ Orders\nOrder creation examples\nJS Utils\nBreaking changes in V3\nSmart contracts\nLiquidity Source and API\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nLimit order protocolLiquidity Source and API\nLiquidity Source and API\nI. 1inch Aggregation Protocol​\n\nThe protocol sources liquidity from various exchanges and is capable of splitting a single trade transaction across multiple DEXes to ensure the best rates.\n\nYou can send your limit orders through Limit Orders API to the 1inch database and then your order will participate in the 1inch Aggregation Protocol.\n\nDocs.\n\nII. Limit Orders API​\n\nAllows you to directly publish orders and fetch listed orders.\n\nEthereum\nBinance Smart Chain\nPolygon\nOptimism\nArbitrum\nFantom\nGnosis chain\nAvalanche\nKlaytn\nAurora\nZkSync\nZkSync-era\nBase\nEdit this page\nPrevious\nRevertReasonParser\nNext\nExamples\nI. 1inch Aggregation Protocol\nII. Limit Orders API"
  },
  {
    "title": "Swagger | 1inch Network",
    "url": "https://docs.1inch.io/docs/aggregation-protocol/api/swagger/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nIntroduction\nGuide\nAPI\nLegal\nSwagger\nSwap params\nQuote params\nSmart contracts\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nAggregation ProtocolAPISwagger\nSwagger\nCAUTION\n\nThe public Swap API api.1inch.io is deprecated. To continue using the Swap API please migrate to the 1inch Developer Portal\n\nEthereum\nBinance Smart Chain\nPolygon\nOptimism\nArbitrum\nGnosis chain\nAvalanche\nFantom\nKlaytn\nAurora\nzkSync\nBase\nEdit this page\nPrevious\nLegal\nNext\nSwap params"
  },
  {
    "title": "Overview | 1inch Network",
    "url": "https://docs.1inch.io/docs/governance/overview/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nOverview\nProposal Lifecycle\nVoting Process\n1inch Network DAO Treasury\nInstant Governance\n1inch Improvement Proposal (1IP) Template\n1IPs\nGlossary\nEducational Resources\nGovernanceOverview\nOverview\n\n1inch Network DAO is a decentralized autonomous organization that governs the 1inch Network. DAO governance decisions can range from allocating Treasury funds for a particular proposal, to deploying a new protocol on the 1inch Network, and everything in between.\n\nThe creation of the 1inch Network DAO marked the move towards full-fledged DAO functionality, providing the community direct control over extended governance mechanisms. All participants in the DAO are working towards a common goal: 1inch Network protocols and the 1INCH token to be completely decentralized, owned and governed by the DAO.\n\n1INCH token is the governance token of the 1inch Network DAO. Anyone may participate in the DAO’s discussions, however only users with 1inch governance tokens may vote on proposals. To ensure that all participants in the governance process have a vested interest in the success of the project, holders of 1INCH must first deposit it in the staking contract (see Voting Process).\n\nEdit this page\nPrevious\nWallet auto-connect\nNext\nProposal Lifecycle"
  },
  {
    "title": "Summary | 1inch Network",
    "url": "https://docs.1inch.io/docs/rabbithole/summary/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nSummary\nFlow\nSwitching between networks\nWallet auto-connect\nGovernance\nEducational Resources\nRabbitholeSummary\nSummary\n\nThe RabbitHole is an innovative feature that aims to solve the issue of sandwich attacks for those wallets which don't support the Flashbots option.\n\nAs of 17.10.22, the feature will be implemented only for MetaMask wallets on the Mainnet. While some wallets support Flashbots, MetaMask doesn't and, therefore, after creating a transaction and signing it with the private key, it is always sent to the memory pool rather than directly to the validators. In the memory pool, transactions are vulnerable to sandwich attacks. So, the 1inch RabbitHole acts as a proxy server and intermediary between MetaMask and Flashbots. This proxy server switches MetaMask from the Mainnet to the ad hoc network RabbitHole, which substitutes the Mainnet as it has the same ID - “1”.\n\nSo, MetaMask signs the transaction and sends it to the blockchain, recognizing the network as the Mainnet. But the transaction is sent via the RabbitHole, which directs it to our node. The node checks the transaction destination and, if it is the 1inch Router, the transaction is sent to Flashbots. If there is another destination, it is sent to the Mainnet\n\nIn the current version of the RabbitHole, the user can’t change the network to the RabbitHole in the dApp and has to do that in MetaMask. There are two reasons for that:\n\nWhen calling MetaMask to change the network, the chain ID is used as the function argument. The Ethereum Mainnet and the RabbitHole have the same chain ID = 1. RPC URL is not specified as an argument, so the app cannot change the grid through this call.\nIf we create any other chain ID for the RabbitHole, it won’t work. E.g., we will create chain ID 666. The chain ID, along with all callData, is hashed in a cryptographic signature. So, this transaction signed in a MetaMask wallet connected to the network with ID = 666 will be available for execution only in the network with ID = 666. If we try to send this transaction to a validator on the Mainnet, it won’t work. We cannot change this parameter on the go, as it is built into the signature to protect transaction data against manipulations. The network change call:\nawait window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x61' }], // chainId must be in hexadecimal numbers });\n\n\nWe will be able to implement the connection of the RabbitHole network from the dApp if MetaMask enables programmatically setting a custom network with the same chain ID but a different RPC URL. Alternatively, if MetaMask can sign the transaction but not broadcast it, there will be no need for the RabbitHole, as it will be possible to implement the Flashbots option.\n\nEdit this page\nPrevious\nSpot Price Aggregator\nNext\nFlow"
  },
  {
    "title": "Spot Price Aggregator | 1inch Network",
    "url": "https://docs.1inch.io/docs/spot-price-aggregator/introduction/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nExamples\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nSpot Price AggregatorSpot Price Aggregator\nSpot Price Aggregator\n\n \n\nThe 1inch spot price aggregator is a set of smart contracts that extract price data for tokens traded on DEXes from the blockchain. To avoid price manipulations within a transaction, the spot price aggregator should ONLY be used off-chain. DO NOT use it on-chain. For off-chain usage see Examples section below.\n\nWrappers​\n\nTo handle wrapped tokens, such as wETH, cDAI, aDAI etc., the 1inch spot price aggregator uses custom wrapper smart contracts that wrap/unwrap tokens at the current wrapping exchange rate.\n\nConnectors​\n\nIf no direct liquidity pair exists between two tokens, the spot price aggregator calculates rates for those coins using another token that has pairs with both of them – a connector token.\n\nSupported Deployments​\nEthereum Mainnet​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nBinance Smart Chain​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nPolygon (Matic)​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nOptimism​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nArbitrum​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nAvax​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nxDai​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nFantom​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nAurora​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nKlaytn​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nzkSync​\nOracle 0xc9bB6e4FF7dEEa48e045CEd9C0ce016c7CFbD500​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nBase​\nOracle 0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8​\nSupported DEXes\nSupported wrappers\nSupported connectors\nPrev oracle versions (legacy)\nExamples​\n\nSingle token-to-ETH price usage\n\nMultiple token-to-ETH prices usage\n\nEdit this page\nPrevious\nExamples\nNext\nSummary\nWrappers\nConnectors\nSupported Deployments\nEthereum Mainnet\nBinance Smart Chain\nPolygon (Matic)\nOptimism\nArbitrum\nAvax\nxDai\nFantom\nAurora\nKlaytn\nzkSync\nBase\nExamples"
  },
  {
    "title": "Introduction | 1inch Network",
    "url": "https://docs.1inch.io/docs/limit-order-protocol/introduction/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nLimit order protocol\nIntroduction\nLimit vs. RFQ Orders\nOrder creation examples\nJS Utils\nBreaking changes in V3\nSmart contracts\nLiquidity Source and API\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nLimit order protocolIntroduction\nIntroduction\n\n1inch limit order protocol is a set of smart contracts that work on any supported EVM based blockchains.\n\nKey features of the protocol are extreme flexibility and high gas efficiency which are achieved by using two different order types - regular Limit Order and RFQ Order.\n\nSmart Contracts allow users to place limit orders and RFQ Orders, that later could be filled on-chain. Both types of orders are data structures created off-chain and signed according to EIP-712.\n\nI. Limit order​\n\nA limit order is a financial instrument with which you can put up an ERC-20 token for sale at a fixed price.\nFor example, you can put up 2 WBTC tokens for sale at the price of 82415 DAI tokens.\n\nThe 1inch limit order protocol has many tools for flexible trade management:\n\nPartial fill\nPredicates\nSingle cancellation\nBunch cancellation\nFullness check\nValidation\n\nNote: For market-making, there are RFQ orders that have special optimization which does not require a large amount of gas for execution.\n\nLimit order execution​\n1inch users can place their limit orders through the 1inch dApp.\nThe signed orders placed by the users can be fetched by anyone using the 1inch Limit Orders Liquidity Source API to execute trades by filling the order on-chain.\nTo fill a limit order on-chain, you need to pass the signed order to the fillOrder method on the contract. You can find the latest contract addresses here.\n\nNote: Both the buyer and seller of the assets being traded must approve their assets to be used by the 1inch limit order contract.\n\nThe Pathfinder algorithm uses the limit orders placed via the 1inch dApp and REST API as a liquidity source, making them available for any 1inch user to fill. This integration ensures that 1inch limit orders are available on the DeFi ecosystem from day one.\nLimit order features​\n\nLimit orders are highly flexible and can be configured with the following features:\n\nOrder execution predicate: This feature allows you to specify certain conditions to be met before the order can be executed.\nFor example, you can set an expiration time based on a certain timestamp or block number.\nYou can also construct any predicate you want, such as checking that a certain price is higher than the oracle price, to implement stop loss or take profit strategies.\nHelper function for asset price evaluation.\nFunction that will allow to extract assets price from arbitrary on-chain source\nCallback: For notifying the maker of the order execution.\nII. RFQ order​\n\nA request for quotation (RFQ) is a business process in which a customer requests a quote from a supplier (market-maker) for the purchase of some tokens.\n\nRFQ orders have different use cases, and are dedicated to market-makers in the first place. The typical scenario is following: Market-maker creates a bunch of RFQ Orders, and exposes it via the API. Trader or the platform algorithm ask for market maker quotes. If the quotes match traders' needs, the trader receives signed RFQ order from the market-maker.\n\nRFQ order features​\n\nGas optimized order with restricted capabilities suitable for market-makers\n\nSupports expiration time\nSupports cancelation by order id\nRFQ Order could be filled only once\nPartial Fill is possible (once)\nSupported tokens​\nERC 20\nERC 721\nERC 1155\nOther token standards could be supported via external extension\nMore resources​\nYou can use Limit Orders within the 1inch dApp\nSmart Contracts repository\nUtils library repository\nEdit this page\nPrevious\nWebSocket API\nNext\nLimit vs. RFQ Orders\nI. Limit order\nLimit order execution\nII. RFQ order\nSupported tokens\nMore resources"
  },
  {
    "title": "Introduction | 1inch Network",
    "url": "https://docs.1inch.io/docs/fusion-swap/introduction/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nFusion swap\nIntroduction\nBecoming a Resolver\nFusion SDK\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nFusion swapIntroduction\nIntroduction\nOverview​\n\nThe 1inch Fusion Mode offers users a way to execute swaps without spending gas or risking being front-run. To the user, Fusion Mode looks like a swap, but technically it is a limit order with a variable exchange rate filled by a third party called a Resolver. An order's exchange rate decreases from the desired rate to the minimal return amount (Dutch auction) until it becomes profitable for Resolvers to fill the order. Multiple resolvers compete for the order to ensure it is filled before the rate falls to the minimal return amount. Here are some examples of opportunities for resolvers to gain profit:\n\nThe Dutch auction constantly decreases the order rate;\nGas economy when filling matching orders;\nGas economy due to batch filling.\n\nFor Resolvers and integrators there is a fusion SDK available to help with the integration.\n\nDutch auction filling rate​\n\nEach order has an auction start timestamp, which is calculated as the order's signature timestamp plus a waiting period. The waiting period is a delay that compensates for different block generation speeds on different networks. Before the auction begins, an order can be filled at the auction start rate, which is the maximum rate that a user can receive. After the auction begins, the order filling rate gradually decreases over time.\n\nThe order filling rate is a piecewise linear function that depends on multiple parameters, such as swap volume, gas costs, and the chosen preset (e.g., fast, fair, auction). To reduce price impact, the source token volume is divided into parts, which results in several price points, assuming that arbitragers will move the price back after each resolver’s trade. This approach benefits users by providing better rates, while also allowing resolvers to make a profit from each transaction.\n\nTherefore, we recommend that resolvers try to partially fill orders by splitting the remainingMakerAmount into 6-10 parts and checking if at least one of those parts can be filled.\n\nBelow is a real-life example.\n\nEdit this page\nPrevious\nIUniswapV3SwapCallback\nNext\nHow to become a resolver\nOverview\nDutch auction filling rate"
  },
  {
    "title": "Introduction | 1inch Network",
    "url": "https://docs.1inch.io/docs/aggregation-protocol/introduction/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\n1inch Network Overview\nAggregation Protocol\nIntroduction\nGuide\nAPI\nSmart contracts\nFusion swap\nLimit order protocol\nSpot Price Aggregator\nRabbithole\nWallet auto-connect\nGovernance\nEducational Resources\nAggregation ProtocolIntroduction\nIntroduction\nCAUTION\n\nThe public Swap API api.1inch.io is deprecated. To continue using the Swap API please migrate to the 1inch Developer Portal\n\nThe 1inch API v5, Pathfinder, is a cutting-edge discovery and routing algorithm, which offers asset exchanges at the best rates on the market. Pathfinder finds the most efficient paths for a token swap, able to split between different protocols and even different market depths in within one protocol in the shortest possible time.\n\nINFO\n\nIf you are an enterprise with significant trading volumes, please complete this application so we can assign you a custom API endpoint. The enterprise endpoint will offer significantly better performance across market rates and response times.\n\nSupported Networks/Chains​\nEthereum Mainnet\nAurora\nArbitrum\nAvalanche\nBase\nBNB Chain\nFantom\nGnosis\nKlaytn\nOptimism\nPolygon\nzkSync Era\nQuick start​\n\nIn order to quickly understand how to make an exchange using the protocol, we suggest you take a quick course: Quick start\n\nEdit this page\nPrevious\n1inch Network Overview\nNext\nQuick start\nSupported Networks/Chains\nQuick start"
  },
  {
    "title": "1inch Network | Leading high capital efficient DeFi protocols",
    "url": "https://docs.1inch.io/",
    "html": "Skip to main content\n1inch Network Docs\nProtocols\nFusion\nGovernance\nOpen Source\nGrants Program\nBug bounty\nNPM\nGitHub\nSearch\nK\nDocumentation Portal\nProtocols\nAggregation Protocol V5\n\nThe 1inch Aggregation Protocol facilitates cost-efficient and secure swap transactions across multiple liquidity sources\n\nIntroduction\n\nDune analytics\n\nSmart contract v4\n\nSmart contract v5\n\nAPI\nSwagger\n\nLimit Order Protocol V3\n\nThe 1inch Limit Order Protocol facilitates the most innovative and flexible limit order swap opportunities in DeFi\n\nIntroduction\n\nDune analytics\n\nSmart contract\n\nAPI\nSwagger\n\nSpot price aggregator\n\nThe 1inch spot price aggregator is a set of smart contracts that extract price data for tokens traded on DEXes from the blockchain\n\nIntroduction\n\nGithub\n\nSmart contract\n\n1inch Fusion mode\n\n1inch Fusion Mode offer users a way to execute swaps without gas spend and risks of being front-run.\n\nIntroduction\n\nHow to become a resolver\n\nResolver’s setup script example\n\nContract interaction\n\nDeveloper links\nGrants program\nIncentivizing individual developers and teams to build on the 1inch Network's protocols and contribute to protocol evolution. Read more\nApply for Grant\nBug bounty program\nOffering monetary rewards to \"white hats\" for successfully discovering and reporting vulnerabilities or bugs in 1inch Network protocols and products. \nReport a Bug\nEducational resources\nA collection of educational resources for developers, including guides, tutorials, and articles. \nView Articles\n1inch dApp\n\nAn entry point to the 1inch Network's tech. The 1inch dApp is #1 DeFi aggregator, offering access to the most liquidity and the best token swap rates on various DEXes, with unique features, including partial fill, the Chi gas token and the ability to find the best swap paths across multiple liquidity sources.\n\nLaunch dApp\nProtocols\nLiquidity Protocol\nAggregation Protocol\nLimit Order Protocol\nGovernance\n1inch DAO\n1INCH token\nForum\nSupport\nHelp center\nAPI\nPress room\nTerms of service\nPrivacy policy\n\nSubscribe to 1inch newsletter\n\nGet the latest news and updates\n\nSubscribe\n© 2024 1inch, All Rights Reserved.\nENS: 1inch.eth\nBUIDL @ETHNewYork 2019"
  }
]